---
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# üßÆ Expressions, Op√©rateurs, Types, Variables

# üèóÔ∏è en construction üèó


<Tabs queryString="onglet">

    <TabItem value="expressions" label="Expressions" default>

        Une expression est un bout de code qui a une valeur et un type.<br/>
        Par exemple :
        - `5` est une expression qui vaut 5 et de type entier (int).
        - `"5"` est une expression de type texte.
        - `5 + 3` est une expression de type entier qui vaut 8.

    </TabItem>

    <TabItem value="operateurs" label="Op√©rateurs" default>

        Il existe plusieurs op√©rateurs qui permettent de construire des expressions √† partir d'autres expressions.<br/>
        Plusieurs sont r√©pertori√©s dans l'[aide-m√©moire](../aidememoire/operateurs), mais nous commencerons avec ceux-ci
        :

        ## Op√©rateurs arithm√©tiques

        | Op√©rateur | Description | Exemple |
        |------------|------------------|-----------------------------|
        | `+` | Addition | `10 + 3` (vaut `13`) |
        | `-` | Soustraction | `10 - 3` (vaut `7`) |
        | `*` | Multiplication | `10 * 3` (vaut `30`) |
        | `/` | Division (float) | `10 / 3` (vaut `3.333...`) |
        | `//` | Division enti√®re | `10 // 3` (vaut `3`) |
        | `%` | Modulo (reste) | `10 % 3` (vaut `1`) |
        | `**` | Puissance | `10 ** 3` (vaut `1000`) |

        ## Op√©rateurs d'affectation

        | Op√©rateur | Description | Exemple |
        |------------|------------------------------------|---------|
        | `=` | Affectation simple | `x = 5` |

    </TabItem>

    <TabItem value="types" label="Types" default>

        En programmation, on veut stocker des valeurs dans des variables, mais ces valeurs ont un type.<br/>
        Le type d'une valeur d√©termine comment on peut l'utiliser et quelles op√©rations sont possibles
        avec cette valeur.

        Voici les [types de donn√©es](../aidememoire/types) de base pour d√©buter en Python :

        ## Types de base

        | Type | Description | Exemple |
        |-----------|------------------------|--------------------|
        | **int** | Nombre entier | `42` |
        | **float** | Nombre d√©cimal | `3.14` |
        | **str** | Cha√Æne de caract√®res | `"Alice"` |
        | **bool** | Bool√©en (vrai ou faux) | `True` |

        Python contient une fonction permettant de conna√Ætre le type d'une expression:

        ```python
        truc = ...
        print( type(truc) )
        ```


        La plupart des langages de programmation on des types de base pour repr√©senter les nombres

        - Entier : 1 2 3 -99 etc.
        - Flottant : 1.0 2.5 -99.9 etc.
        - Texte : "bonjour" "salut" "123" etc.
        - Bool√©en : True False

        - *5 + 3* est une expression de type entier qui vaut 8
        - *"coucou " + str(81)* est une expression de type texte qui vaut "coucou 8"

        On voit que *+* ne fait pas la m√™me chose selon le type de son op√©rateur. Pour des nombres
        il fait la somme habituelle. Pour du texte, il met les 2 textes bout √† bout.

        Les fonctions comme **str()** peuvent avoir un type. Ici **str** transforme une
        expression qu'on lui passe en texte:
        - *81* est un entier qui vaut 81
        - *str(81)* est un texte constitu√© du caract√®re *8* suivi du caract√®re *1*


        ### Ex√©cution : √©valuateur d'expression
        On peut vite se laisser emporter et construire des expressions assez complexes:
        ```python
        str( 5 + 8 * (7 + 98 * 6) / 5 / 6.7 * 10 - 4)
        ```

        Pour √©valuer cette expression petit bout par petit bout, on peut utiliser un √©valuateur d'expression.
        Il faut placer un point d'arr√™t sur la ligne dans le script.

        ## Types compos√©s

        Il existe aussi des [structures de donn√©es](../aidememoire/structuresdonnes) plus complexes pour stocker des donn√©es, que nous verrons plus tard.

    </TabItem>

    <TabItem value="variables" label="Variables" default>

        Un nom qui va d√©signer plusieurs valeurs au fil du temps.

        Dans un premier temps on va avoir des "variables" qui "varient" √† chaque assignation.

        Il est donc important de voir ce qu'est une assignation

        ```python
        nomDeMaVariable = expression
        ```
        - Ceci n'est pas une √©galit√© comme en maths
        - on calcule expression, ce qui nous donne une valeur et un type
        - on associe, on "assigne" cette valeur et type au *nomDeMaVariable*

        Ex√©cute en mode d√©bogage et on regarde la valeur de x changer.

        TODO ajouter un exemple avec du hasard

        ```python
        x = 5 * 6
        y = 2 * x
        x = x * x + 25.6
        x = str(5 - x)
        ```
        - si on √©tait en maths, y devrait toujours valoir le double de x
        - si x √©volue dans le temps
        - comme on a pos√© y qui est 2*x
        - on devrait avoir y qui √©volue avec le temps
        - en programmation le **=** n'est pas une √©quation, c'est une **assignation**
        - on √©value l'expression en partie droite *2 * x*
        - comme x vaut 30 √† ce moment l√†, √ßa donne 60
        - on assigne cette valeur dans la variable y
        - si on veut assigner une nouvelle valeur, il faut un autre *y = ...*

    </TabItem>

    <TabItem value="fonctions" label="Fonctions" default>

        :::info Fonctions

        Une fonction correspond √† un ensemble d'instructions r√©utilisables pour lesquelles un nom leur a √©t√© attribu√©.
        Le nom de la fonction est g√©n√©ralement choisi en cons√©quence pour √™tre significatif afin d'aider les personnes
        d√©veloppeuses. Par exemple, on peut se douter avec le nom de la fonction "print" que quelque chose va √™tre
        imprimer/afficher √† quelque part. Si on regarde la documentation de la fonction "print" on peut apprendre
        qu'elle permet d'√©crire du contenu dans le terminal.


        ***Comprendre le fonctionnement d'une fonction avant son utilisation***
        Quand on fait appel √† une fonction, il n'est pas toujours important de comprendre les instructions derri√®res et
        d'aller inspecter son code.
        Il faut simplement s'assurer de comprendre comment l'utiliser. Il faut se poser par exemple comme question :
        - la fonction n√©cessite quoi comme information √™tre utilis√©e? (on nomme ces informations attendues par une
        fonction des param√®tres)
        - la fonction retourne telle une valeur qu'on pourrait par la suite stocker dans une variable pour la
        r√©utiliser?
        - est-ce qu'il y a des cas limites que la fonction ne peut pas g√©r√©e ou pouvant causer des erreurs (on va alors
        parler d'exceptions)

        ***Les param√®tres***
        Pour ex√©cuter (on dit √©galement appeler) une fonction, il faut √©crire le nom de la fonction suivi de parenth√®se
        ()
        Entre les parath√®ses, si la fonction n√©cessite des param√®tres, ils doivent entre fournies s√©par√©s par une
        virgule.
        Le nombre de param√®tres et l'ordre sont importants comme nous allons le voir avec des exemples.


        ***Conserver la valeur de retour d'un appel d'une fonction***
        Si le r√©sultat d'un appel de fonction doit √™tre r√©utilis√© plus tard, vous pouvez le conserver dans une variable

        ```python
        #Exemple d'une fonction pouvant recevoir aucun param√®tre en entr√©e
        saisie_utilisateur = input() #permet de demander √† l'utilisateur de saisir une entr√©e,
        #la fonction retourne une str avec la valeur saisie
        print(saisie_utilisateur)

        #Exemple d'une variante de la m√™me fonction, mais acceptant un param√®tre en entr√©e
        saisie_utilisateur = input("Veuillez saisir votre pr√©nom:")
        print(saisie_utilisateur)

        #Exemple de fonction pouvant recevoir un nombre pr√©cis de param√®tres :
        longueur = len(saisie_utilisateur) #permet d'obtenir le nombre de caract√®res d'une str
        valeur_convertir_en_entier = int("3") #permet d'obtenir un nombre entier √† partir d'une str
        valeur_convertir_en_float = float("3.41") #permet d'obtenir un nombre √† virgule entier √† partir d'une str
        valeur_puissance = pow(2,3) #permet d'obtenir le r√©sultat de 2 √† la puissance 3 (l'ordre des param√®tres est
        important)
        valeur_arrondie = round(3.14159, 2) #permet d'arrondir un float √† la deuxi√®me position apr√®s la virgule
        type_variable = type(longueur) #permet d'obtenir le type d'une variable
        nombre1_en_str = input("Entr√©e un nombre") #obtenir un nombre (en 2 √©tapes)
        nombre1 = int(nombre1_en_str)
        nombre2 = int(input("Entr√©e un second nombre")) #obtenir un nombre (en 1 √©tape), l'expression combine les 2
        fonctions

        #Exemple de fonction pouvant recevoir un nombre infini de param√®tres :
        print("le r√©sultat de ", nombre1, " multipli√© par ", nombre2, " est :", nombre1 * nombre2)

        #Exemple de cr√©ation d'une str √† partir d'√©l√©ments variables et constants (f-strings)
        message = f"Le r√©sultat de {nombre1} multipli√© par {nombre2} est : {nombre1 * nombre2}"
        print(message)
        ```

        :::

    </TabItem>

    <TabItem value="modules" label="Modules" default>

        :::info Modules

        Certaines fonctions qui ne sont pas disponible par d√©faut. Pour √™tre en mesure d'utiliser ces fonctions, nous
        devons pr√©alablement ajouter une instruction dans notre fichier Python qui va servir √† charger le fichier
        contenant ces fonctions (on nommera ce fichier un Module). G√©n√©ralement, ces instructions sont plac√©e au d√©but
        du fichier. Par la suite, pour utiliser/appeler une fonction du module, il faut simplement pr√©c√©der le nom de la
        fonction par le nom de son module.

        ```python
        import math #Importer le module "math"
        print(math.sqrt(16)) # R√©sultat : 4.0
        ```

        Vous allez d√©couvrir les modules suivants :
        - math : ensemble de fonctions math√©matiques avanc√©es comme les logarithmes, les exposants, les racines carr√©es
        et les fonctions trigonom√©triques
        - random : permet de g√©n√©rer des nombres al√©atoires, de s√©lectionner des √©l√©ments au hasard et de simuler des
        √©v√©nements probabilistiques
        - os : ensemble de fonctionnalit√©s pour int√©ragir avec le syst√®me d'exploitation (ex : Windows). Par exemple
        permettre de pouvoir manipuler des fichiers ou des r√©pertoires.
        - sys : permet d'acc√©der √† des informations sur l'environnement du programme et manipuler les entr√©es et sorties
        - time : contient des fonctions pour manipuler le temps et les dates, comme la mesure du temps √©coul√© et les
        conversions de format
        - csv : facilite la lecture et l'√©criture de fichiers CSV qui est un format couramment utilis√©s pour stocker des
        donn√©es tabulaires

        :::

    </TabItem>

    <TabItem value="biblio" label="Biblioth√®ques" default>

        :::info Biblioth√®ques

        Parfois plusieurs modules sont regroup√©es ensemble pour former un tout r√©utilisable et
        partageable facilement. Nous appelons ce regroupement une biblioth√®que. Afin de pouvoir utiliser des
        fonctionnalit√©s des modules d'une biblioth√®que, il faut pr√©alablement avoir install√© la biblioth√®que a l'aide de
        l'utilitaire "pip install" que nous verrons √©ventuellement. Par la suite, dans notre code, une biblioth√®que
        s'utilise relativement de la m√™me mani√®re qu'un simple module.

        :::

    </TabItem>

    <TabItem value="matplotlib" label="Matplotlib" default>

        :::info G√©n√©rer des Graphiques

        Nous allons utilisez dans le cadre du cours la biblioth√®que Matplotlib servant √† la visualisation des donn√©es en
        Python. Cette biblioth√®que est TR√àS flexible et permet de r√©aliser des graphiques autant simples que complexes.
        La biblioth√®que permet de personnaliser pratiquement tous les √©l√©ments et permet de r√©aliser autant des
        graphiques √† lignes, √† barres, des histogrammes ou des nuages de points. La biblioth√®que permet m√™me de
        superposer plusieurs graphes sur une seule figure. Un autre avantage de Matplotlib est compatible avec d'autres
        biblioth√®ques √† caract√®re scientifique comme NumPy, Pandas ou SciPy.

        Nous aurons un cours complet d√©di√© √† l'utilisation de celle-ci.
        Nous aborderons √©galement l'existante d'autres biblioth√®ques (Seaborn, Ggplot2).
        Voici un exemple

        ```python
        import matplotlib.pyplot as plt

        # √Çge en ann√©es
        age = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        # Taille correspondante en cm (exemple fictif)
        taille = [50, 75, 85, 95, 105, 112, 118, 124, 130, 135, 140]

        # Cr√©ation du graphique
        plt.plot(age, taille, marker='o', linestyle='-', color='g', label="Taille en fonction de l'√¢ge")

        # Ajout de titres et labels
        plt.xlabel("√Çge (ann√©es)")
        plt.ylabel("Taille (cm)")
        plt.title("Courbe de Croissance de l'Enfant")
        plt.legend()

        # Affichage du graphique
        plt.show()
        ```

        :::

    </TabItem>

    <TabItem value="exercices" label="Exercices">

        ::::warning Exercices de compr√©hension

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        ::::

        ::::tip Exercices de cr√©ation

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        ::::

    </TabItem>

</Tabs>

