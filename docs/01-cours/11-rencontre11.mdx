---
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import useBaseUrl from '@docusaurus/useBaseUrl';

# ğŸ¼ Pandas et ğŸ¤– Scikit-learn

# ğŸ—ï¸ en construction ğŸ—

<Tabs queryString="onglet">

    <TabItem value="data" label="Analyse de donnÃ©es" default>

        :::tip ğŸ’¡ Introduction Ã  l'analyse de donnÃ©es

        ğŸ“Š Pour votre **TP2**, vous allez devoir manipuler des **donnÃ©es rÃ©elles** :

        - ğŸ“¥ Charger des ensembles de donnÃ©es Ã  partir de fichiers **CSV**.
        - ğŸ§¹ **Nettoyer et prÃ©traiter** les donnÃ©es pour les rendre exploitables.
        - ğŸ” **Analyser** les donnÃ©es pour en extraire des informations pertinentes.
        - ğŸ“ˆ **Visualiser** les donnÃ©es Ã  l'aide de graphiques.
        - ğŸ¤– Utiliser des techniques dâ€™**apprentissage automatique** pour construire des modÃ¨les prÃ©dictifs.

        ğŸ§  Cela nÃ©cessite une bonne comprÃ©hension des **concepts** et des **outils dâ€™analyse de donnÃ©es**.

        ---

        ğŸ”¬ Lâ€™**analyse de donnÃ©es** est un processus essentiel qui consiste Ã  examiner, nettoyer, transformer et modÃ©liser des donnÃ©es dans le but de **dÃ©couvrir des informations utiles**, **informer des conclusions** et **soutenir la prise de dÃ©cision**.

        ---

        ğŸ§° **BibliothÃ¨ques Python couramment utilisÃ©es** pour lâ€™analyse de donnÃ©es :

        - ğŸ¼ **Pandas** : pour la **manipulation et lâ€™analyse** de donnÃ©es, offrant des structures de type *DataFrame*.
        - ğŸ”¢ **NumPy** : pour le **calcul scientifique** et les opÃ©rations sur des tableaux multidimensionnels.
        - ğŸ¤– **Scikit-learn** : pour lâ€™**apprentissage automatique** et la modÃ©lisation prÃ©dictive.
        - ğŸ§  **Keras** et **TensorFlow** : pour le dÃ©veloppement de modÃ¨les dâ€™**apprentissage profond** (*deep learning*).
        - ğŸ¨ **Matplotlib** et **Seaborn** : pour la **visualisation** de donnÃ©es.
        - â€¦ et bien dâ€™autres selon les besoins !

        ---

        ğŸ§© Vous connaissez dÃ©jÃ  :
        - ğŸ¨ **Matplotlib** pour la **visualisation**
        - ğŸ”¢ **NumPy** pour les **calculs numÃ©riques**

        ğŸ“… Cette semaine, nous allons apprendre Ã  utiliser deux nouvelles bibliothÃ¨ques essentielles pour votre TP2 :
        ğŸ¼ **Pandas** et ğŸ¤– **Scikit-learn**.<br />
        ğŸ‘‰ La semaine prochaine, nous aborderons les concepts dâ€™**intelligence artificielle** et dâ€™**apprentissage profond** (*deep learning*).

        :::

    </TabItem>

    <TabItem value="pandas" label="ğŸ¼ Pandas">

        :::info Introduction Ã  ğŸ¼ Pandas

        Pandas est une bibliothÃ¨que Python essentielle pour la manipulation et l'analyse de donnÃ©es. Elle offre des structures de donnÃ©es flexibles et performantes, telles que les *DataFrames*, qui facilitent le traitement des donnÃ©es tabulaires.

        :::

        ---

        :::info Le DataFrame

        Le **DataFrame** est la structure de donnÃ©es principale de Pandas. Il s'agit d'une table bidimensionnelle, similaire Ã  une feuille de calcul Excel, oÃ¹ les donnÃ©es sont organisÃ©es en lignes et en colonnes. Chaque colonne peut contenir des types de donnÃ©es diffÃ©rents (nombres, chaÃ®nes de caractÃ¨res, dates, etc.).

        On peut crÃ©er un DataFrame Ã  partir de diverses sources de donnÃ©es, telles que des fichiers CSV, des bases de donnÃ©es SQL, ou mÃªme des dictionnaires Python.

        :::

        ---

        :::info CrÃ©ation d'un DataFrame Ã  partir d'un dictionnaire
        ```python
        import pandas as pd

        # CrÃ©ation d'un DataFrame Ã  partir d'un dictionnaire
        data = {'Nom': ['Alice', 'Bob', 'Charlie'],
                'Ã‚ge': [25, 30, 35],
                'Ville': ['Paris', 'Lyon', 'Marseille']}
        df = pd.DataFrame(data)

        # Affichage du DataFrame
        print(df)
        ```
        Cela produira le DataFrame suivant :
        ```
               Nom  Ã‚ge      Ville
        0    Alice   25      Paris
        1      Bob   30       Lyon
        2  Charlie   35  Marseille
        ```
        - Les clÃ©s du dictionnaire deviennent les noms des colonnes, et chaque liste associÃ©e Ã  une clÃ© devient une colonne de donnÃ©es.
        - La premiÃ¨re colonne (0, 1, 2) est l'index par dÃ©faut des lignes.
        - La premiÃ¨re ligne reprÃ©sente les en-tÃªtes des colonnes.
        - Chaque ligne suivante reprÃ©sente un enregistrement (une personne dans cet exemple).

        :::

        ---

        :::info Lire un fichier CSV avec Pandas

        Le fichier <a href={useBaseUrl('/ressources/csv/tips_dataset.csv')} download="tips_dataset.csv">tips_dataset.csv</a> contient des donnÃ©es sur les pourboires donnÃ©s dans un restaurant, lees colonnes suivantes : le montant total de la facture, le pourboire, le sexe du serveur, si le client est fumeur, le jour de la semaine, le moment de la journÃ©e (dÃ®ner/*lunch* ou souper/*dinner*) et la taille du groupe :

        ```csv
        total_bill,tip,sex,smoker,day,time,size
        16.99,1.01,Female,No,Sun,Dinner,2
        10.34,1.66,Male,No,Sun,Dinner,3
        21.01,3.5,Male,No,Sun,Dinner,3
        23.68,3.31,Male,No,Sun,Dinner,2
        ...
        ```
        Si vous le <a href={useBaseUrl('/ressources/csv/tips_dataset.csv')} download="tips_dataset.csv">tÃ©lÃ©chargez</a> et le placez dans votre projet Pycharm, vous pouvez le lire avec Pandas comme ceci :
        ```python
        import pandas as pd

        # Lire le fichier CSV dans un DataFrame
        df = pd.read_csv('tips_dataset.csv')

        # Afficher les premiÃ¨res lignes du DataFrame
        print(df.head())
        ```
        Cela produira un DataFrame qui ressemble Ã  ceci (seules les 5 premiÃ¨res lignes sont affichÃ©es) :
        ```
           total_bill   tip     sex smoker  day    time  size
        0       16.99  1.01  Female     No  Sun  Dinner     2
        1       10.34  1.66    Male     No  Sun  Dinner     3
        2       21.01  3.50    Male     No  Sun  Dinner     3
        3       23.68  3.31    Male     No  Sun  Dinner     2
        4       24.59  3.61  Female     No  Sun  Dinner     4
        ```
        Nous utiliserons ces donnÃ©es pour illustrer diverses opÃ©rations avec Pandas.
        - Chargez-les et expÃ©rimentez par vous-mÃªme ! ğŸ¯

        :::

        ---

        ::::info OpÃ©rations clÃ©s avec ğŸ¼ Pandas

        Une fois vos donnÃ©es chargÃ©es dans un DataFrame, vous pouvez effectuer une grande variÃ©tÃ© dâ€™opÃ©rations pour les explorer, les transformer et en extraire de lâ€™information utile.

        Voici quelques exemples pratiques avec le DataFrame `df` du fichier **tips_dataset.csv** :

        ---

        ### ğŸ‘€ Afficher et explorer les donnÃ©es

        ```python
        # Affiche les 5 premiÃ¨res lignes du DataFrame
        print(df.head())

        # Affiche les informations sur les colonnes et les types de donnÃ©es
        df.info()

        # Affiche des statistiques descriptives (moyenne, min, max, etc.)
        print(df.describe())
        ```
        Cette derniÃ¨re commande `df.describe()` permet dâ€™obtenir un rÃ©sumÃ© statistique rapide des colonnes numÃ©riques du DataFrame, incluant des mesures telles que la moyenne, lâ€™Ã©cart-type, les valeurs minimales et maximales, ainsi que les quartiles :
        ```
               total_bill         tip        size
        count  244.000000  244.000000  244.000000
        mean    19.785943    2.998279    2.569672
        std      8.902412    1.383638    0.951100
        min      3.070000    1.000000    1.000000
        25%     13.347500    2.000000    2.000000
        50%     17.795000    2.900000    2.000000
        75%     24.127500    3.562500    3.000000
        max     50.810000   10.000000    6.000000
        ```

        ---

        ### ğŸ¯ SÃ©lectionner des colonnes et des lignes

        ```python
        # SÃ©lection d'une colonne
        df["total_bill"]

        # SÃ©lection de plusieurs colonnes
        df[["total_bill", "tip", "day"]]

        # SÃ©lection d'une ligne par son index
        df.iloc[3]  # 4Ã¨me ligne (index 3)
        ```

        :::warning Attention
        Toutes ces opÃ©rations (et celles qui suivent) **ne modifient pas** le DataFrame original `df`. Elles renvoient un **nouveau DataFrame** basÃ© sur les critÃ¨res spÃ©cifiÃ©s. Il est cependant possible de stocker le rÃ©sultat dans une nouvelle variable si besoin :
        ```python
        df_filtered = df[df["tip"] > 5]
        ```
        `df_filtered` contiendra alors un nouveau DataFrame avec uniquement les lignes oÃ¹ le pourboire est supÃ©rieur Ã  5.
        :::

        ---

        ### ğŸ” Filtrer les donnÃ©es

        ```python
        # Filtrer les lignes oÃ¹ le pourboire est supÃ©rieur Ã  5
        df[df["tip"] > 5]

        # Filtrer les lignes pour le jour "Sun" et le temps "Dinner"
        df[(df["day"] == "Sun") & (df["time"] == "Dinner")]

        # Filtrer les lignes oÃ¹ le serveur est une femme et le pourboire supÃ©rieur Ã  3
        df[(df["sex"] == "Female") & (df["tip"] > 3)]
        ```

        ---

        ### ğŸ“ˆ Trier et ordonner les donnÃ©es

        ```python
        # Trier par montant total de la facture (total_bill) en ordre croissant
        df.sort_values(by="total_bill")

        # Trier par pourboire (tip) en ordre dÃ©croissant
        df.sort_values(by="tip", ascending=False)

        # Trier par jour puis par montant total de la facture
        df.sort_values(by=["day", "total_bill"])
        ```

        ---

        ### ğŸ§® CrÃ©er de nouvelles colonnes

        ```python
        # Ajouter une colonne pour le pourcentage de pourboire
        df["tip_percentage"] = (df["tip"] / df["total_bill"]) * 100
        ```
        Cela ajoute une nouvelle colonne `tip_percentage` au DataFrame, calculant le pourcentage de pourboire par rapport au montant total de la facture :
        ```
           total_bill   tip     sex smoker  day    time  size  tip_percentage
        0       16.99  1.01  Female     No  Sun  Dinner     2        5.944673
        1       10.34  1.66    Male     No  Sun  Dinner     3       16.054159
        2       21.01  3.50    Male     No  Sun  Dinner     3       16.658734
        3       23.68  3.31    Male     No  Sun  Dinner     2       13.978041
        4       24.59  3.61  Female     No  Sun  Dinner     4       14.680765
        ```

        ---

        ### ğŸ§  Statistiques et agrÃ©gations

        ```python
        # Moyenne du pourboire
        tip_moyen = df["tip"].mean()
        print(tip_moyen) # affiche 2.99827868852459

        # Moyenne du pourboire par jour
        df_tip_jour = df.groupby("day")["tip"].mean()
        print(df_tip_jour)
        ```
        Cela produira une sortie similaire Ã  :
        ```
        day
        Fri     2.734737
        Sat     2.993103
        Sun     3.255132
        Thur    2.771452
        Name: tip, dtype: float64
        ```
        On voit que c'est plus payant le dimanche ! ğŸ˜‰

        ---

        ### ğŸ§¹ Nettoyage de donnÃ©es

        ```python
        # Supprimer les lignes avec des valeurs manquantes
        df_clean = df.dropna()
        ```

        ---

        ### ğŸ“Š Visualisation rapide (avec Matplotlib intÃ©grÃ©)

        ```python
        import pandas as pd
        import matplotlib.pyplot as plt

        # Lire le fichier CSV dans un DataFrame
        df = pd.read_csv('tips_dataset.csv')

        # Ajouter une colonne pour le pourcentage de pourboire
        df["tip_percentage"] = (df["tip"] / df["total_bill"]) * 100

        # Histogramme du pourcentage de pourboire
        df["tip_percentage"].plot(kind="hist", bins=20, title="Distribution du pourcentage de pourboire")
        plt.xlabel("Pourcentage de pourboire")
        plt.ylabel("FrÃ©quence")
        plt.grid(which='both', linestyle='--', linewidth=0.5)
        plt.show()

        # BoÃ®te Ã  moustaches du pourcentage de pourboire par jour
        df.boxplot(column="tip_percentage", by="day", grid=False)
        plt.title("Pourcentage de pourboire par jour")
        plt.suptitle("")  # Supprimer le titre par dÃ©faut
        plt.xlabel("Jour")
        plt.ylabel("Pourcentage de pourboire")
        plt.grid(which='both', linestyle='--', linewidth=0.5)
        plt.show()
        ```

        <Row>
          <Column size={6}>
            <div style={{ textAlign: "left" }}>
              <img
                src={require('/img/cours/r11_histogramme_pourcentage_pourboire.png').default}
                alt="Histogramme des pourboires"
                style={{ maxWidth: '100%', height: 'auto' }}
              />
            </div>
          </Column>

          <Column size={6}>
            <div style={{ textAlign: "right" }}>
              <img
                src={require('/img/cours/r11_boxplot_pourcentage_pourboire_par_jour.png').default}
                alt="Boxplot pourcentage pourboire par jour"
                style={{ maxWidth: '100%', height: 'auto' }}
              />
            </div>
          </Column>
        </Row>

        ---

        ğŸ’¡ **En rÃ©sumÃ© :**
        - `df.head()` âœ aperÃ§u rapide
        - `df[...]` âœ sÃ©lection ou filtrage
        - `df.sort_values()` âœ tri
        - `df.groupby()` âœ regroupement et statistiques
        - `df.plot()` âœ visualisation rapide

        Pandas vous permet de passer **dâ€™un simple fichier CSV Ã  une analyse complÃ¨te** en quelques lignes seulement. ğŸ¯

        ::::

    </TabItem>

    <TabItem value="learn" label="ğŸ¤– Scikit-learn">

        :::info Introduction Ã  ğŸ¤– Scikit-learn

        Scikit-learn est une bibliothÃ¨que Python puissante pour l'apprentissage automatique. Elle fournit des outils simples et efficaces pour la modÃ©lisation prÃ©dictive, y compris des algorithmes de classification, de rÃ©gression et de clustering.

        ### Concepts clÃ©s de Scikit-learn
        - **ModÃ¨les** : Scikit-learn propose une large gamme d'algorithmes d'apprentissage automatique, tels que les forÃªts alÃ©atoires, les machines Ã  vecteurs de support (SVM) et les rÃ©seaux de neurones.
        - **PrÃ©traitement des donnÃ©es** : La bibliothÃ¨que offre des outils pour normaliser, standardiser et encoder les donnÃ©es avant de les utiliser dans des modÃ¨les.
        - **Ã‰valuation des modÃ¨les** : Scikit-learn fournit des mÃ©triques pour Ã©valuer la performance des modÃ¨les, telles que la prÃ©cision, le rappel et la courbe ROC (non, non, pas *Rest of Canada* mais plutÃ´t *Receiver Operating Characteristic*).
        - **Pipeline** : Permet de chaÃ®ner plusieurs Ã©tapes de traitement et de modÃ©lisation en un seul objet.

        ğŸ‘‰ Cette semaine, nous allons nous concentrer sur l'utilisation de Scikit-learn pour des tÃ¢ches simples de rÃ©gression, en mettant l'accent sur la visualisation des rÃ©sultats.

        :::

        ---

        :::info ğŸš— DÃ©monstration : Consommation dâ€™essence et caractÃ©ristiques des voitures

        Nous utiliserons le jeu de donnÃ©es classique **Auto MPG** (*Miles per Gallon*) pour explorer la relation entre la **consommation dâ€™essence** (`mpg`) et des variables comme le **poids** (`weight`) ou le **nombre de cylindres** (`cylinders`).
        - Ce jeu de donnÃ©es (*dataset*) est trÃ¨s vintage (annÃ©es 70-80 ) mais reste un excellent exemple pÃ©dagogique.
        - Vous pouvez le tÃ©lÃ©chargez ici : <a href={useBaseUrl('/ressources/csv/mpg_dataset.csv')} download="mpg_dataset.csv">mpg_dataset.csv</a>

        ---

        ### ğŸ§° Chargement du jeu de donnÃ©es

        ```python
        import pandas as pd

        # Chargement du jeu de donnÃ©es
        df = pd.read_csv('mpg_dataset.csv')

        # AperÃ§u
        print(df.head())
        df.info()
        ```
        ```
            mpg  cylinders  displacement  ...  model_year  origin                       name
        0  18.0          8         307.0  ...          70     usa  chevrolet chevelle malibu
        1  15.0          8         350.0  ...          70     usa          buick skylark 320
        2  18.0          8         318.0  ...          70     usa         plymouth satellite
        3  16.0          8         304.0  ...          70     usa              amc rebel sst
        4  17.0          8         302.0  ...          70     usa                ford torino

        [5 rows x 9 columns]

        RangeIndex: 398 entries, 0 to 397
        Data columns (total 9 columns):
         #   Column        Non-Null Count  Dtype
        ---  ------        --------------  -----
         0   mpg           398 non-null    float64
         1   cylinders     398 non-null    int64
         2   displacement  398 non-null    float64
         3   horsepower    392 non-null    float64
         4   weight        398 non-null    int64
         5   acceleration  398 non-null    float64
         6   model_year    398 non-null    int64
         7   origin        398 non-null    object
         8   name          398 non-null    object
        dtypes: float64(4), int64(3), object(2)
        memory usage: 28.1+ KB
        ```
        Ce jeu de donnÃ©es contient 398 entrÃ©es (voitures) avec les 9 colonnes suivantes :
        1. `mpg` : consommation en miles par gallon
        2. `cylinders` : nombre de cylindres
        3. `displacement` : cylindrÃ©e en pouces cubes
        4. `horsepower` : puissance en chevaux
        5. `weight` : poids en livres
        6. `acceleration` : temps dâ€™accÃ©lÃ©ration de 0 Ã  60 mph
        7. `model_year` : annÃ©e du modÃ¨le
        8. `origin` : pays dâ€™origine (usa, europe, japan)
        9. `name` : nom du modÃ¨le

        Ce qui nous intÃ©resse ici, câ€™est de voir comment certaines caractÃ©ristiques (ex. poids, cylindres) influencent la consommation (`mpg`, premiÃ¨re colonne).

        ---

        ### ğŸ” Exploration rapide

            Regroupons les voitures par nombre de cylindres et calculons la moyenne de consommation pour chaque groupe :
        ```python
        # Moyenne de la consommation par nombre de cylindres
        print(df.groupby("cylinders")["mpg"].mean())
        ```
        ```
        cylinders
        3    20.550000
        4    29.286765
        5    27.366667
        6    19.985714
        8    14.963107
        Name: mpg, dtype: float64
        ```
        ğŸ’¡ On observe une relation **inverse** : Ã  l'exception des petits 3-cylindres, on dirait que plus il y a de cylindres, plus la mesure de consommation (mpg) diminue. ğŸ¤”<br />
            C'est plutÃ´t logique : plus une voiture a de cylindres, plus elle consomme dâ€™essence (donc moins elle parcourt de miles par gallon).
            Mais c'est un peu mÃ©langeant, car on est plutÃ´t habituÃ© Ã  penser Ã  l'envers, soit en litres consommÃ©s aux 100 km (L/100km), oÃ¹ une consommation plus faible est donc meilleure.

        ğŸ‘‰ Nous allons donc crÃ©er une nouvelle colonne `l_par_100km` pour convertir `mpg` en litres aux 100 km :
        ```python
        # Conversion mpg -> L/100km
        df["l_par_100km"] = 235.214583 / df["mpg"]
        ```
            Refaisons le mÃªme calcul avec cette nouvelle colonne :
        ```python
        print(df.groupby("cylinders")["l_par_100km"].mean())
        ```
        ```
        cylinders
        3    11.578018
        4     8.333277
        5     9.103094
        6    12.106109
        8    16.235661
        Name: l_par_100km, dtype: float64
        ```

            Visualisons maintenant la relation entre le poids (`weight`) et la consommation (`l_par_100km`) avec un graphique de dispersion (`scatter plot`) :
        ```python
        # Visualisation simple
        import matplotlib.pyplot as plt

        plt.scatter(df["weight"], df["l_par_100km"], alpha=0.6)

        plt.xlabel("Poids du vÃ©hicule (lbs)")
        plt.ylabel("Consommation d'essence (L/100km)")
        plt.title("Consommation d'essence en fonction du poids du vÃ©hicule")

        plt.show()
        ```
        <img src={require('/img/cours/r11_poids_vs_conso_1.png').default} width="50%"/>

        ğŸ’¬ On observe une tendance claire : plus le poids du vÃ©hicule augmente, plus la consommation en litres aux 100 km augmente Ã©galement. Cela confirme notre intuition que les voitures plus lourdes consomment plus dâ€™essence.

        ---

        ### ğŸ§® RÃ©gression linÃ©aire simple (Scikit-learn)

        Nous allons modÃ©liser cette relation avec une rÃ©gression linÃ©aire (`LinearRegression`).

            PrÃ©parons d'abord les donnÃ©es :
        ```python
        # Suppression des valeurs manquantes (seulement pour les colonnes utilisÃ©es : l_par_100km et weight)
        df = df.dropna(subset=["l_par_100km", "weight"])

        # PrÃ©paration des variables
        X = df[["weight"]]    # variable explicative
        y = df["l_par_100km"]         # variable cible
        ```

        Il est trÃ¨s important de bien comprendre ici la structure de `X` et `y` :
        - `X` est un DataFrame Ã  2 dimensions (mÃªme si une seule colonne) : il doit toujours Ãªtre en 2D pour Scikit-learn.
        - `y` est une Series (1D) contenant les valeurs cibles.

        Ici :
        - `X` est une matrice 2D de dimensions (n_samples, n_features) oÃ¹ `n_samples` est le nombre de voitures et `n_features` est 1 (le poids).
        - `y` est un vecteur 1D de longueur `n_samples` contenant les valeurs de consommation (l_par_100km).

        Plus prÃ©cisÃ©ment, comme on a 398 voitures, `X` aura une forme (398, 1) et `y` aura une forme (398,) :
        <Row>
            <Column>
                ```python
                print(X)
                ```
                ```
                     weight
                0      3504
                1      3693
                2      3436
                3      3433
                4      3449
                ..      ...
                393    2790
                394    2130
                395    2295
                396    2625
                397    2720

                [398 rows x 1 columns]
                ```
            </Column>
            <Column>
                ```python
                print(y)
                ```
                ```

                0      13.067477
                1      15.680972
                2      13.067477
                3      14.700911
                4      13.836152
                         ...
                393     8.711651
                394     5.345786
                395     7.350456
                396     8.400521
                397     7.587567
                Name: l_par_100km, Length: 398, dtype: float64

                ```
            </Column>
        </Row>

        EntraÃ®nons maintenant le modÃ¨le de rÃ©gression linÃ©aire :
        ```python
        from sklearn.linear_model import LinearRegression

        # ModÃ¨le linÃ©aire
        model = LinearRegression().fit(X, y) # c'est ici que le modÃ¨le travaille
                                             # pour apprendre la relation entre X et y

        print("Score RÂ² :", model.score(X, y))

        print("Coefficient :", model.coef_[0])
        print("Intercept :", model.intercept_)
        ```
        ```
        Score RÂ² : 0.7836118983544517
        Coefficient : 0.0040789144329788085
        Intercept : -0.9030520509041988
        ```
        - Un score RÂ² de 0.78 indique que le modÃ¨le explique environ 78% de la variance observÃ©e dans la consommation (`l_par_100km`) en fonction du poids (c'est une forte relation linÃ©aire).
        - Le coefficient positif (0.00408) confirme que la relation est directe : **plus le poids augmente, plus la consommation (L/100km) augmente**.
        - La relation entre le poids et la consommation peut donc Ãªtre modÃ©lisÃ©e par la formule de la droite de rÃ©gression suivante :
        $$
        \text{l\_par\_100km} \quad = \quad 0.00408 \times \text{weight} - 0.903
        $$

        ---

        ### ğŸ“ˆ Visualisation de la rÃ©gression

        ```python
        plt.scatter(X, y, label="DonnÃ©es rÃ©elles", alpha=0.6)

        # On ajoute la droite de rÃ©gression :
        plt.plot(X, model.predict(X), color="red", label="RÃ©gression linÃ©aire")

        plt.xlabel("Poids du vÃ©hicule (lbs)")
        plt.ylabel("Consommation d'essence (L/100km)")
        plt.title("RÃ©gression linÃ©aire : Poids vs Consommation")
        plt.legend()

        plt.show()
        ```
        <img src={require('/img/cours/r11_poids_vs_conso_2.png').default} width="50%"/>

        ğŸ’¬ On obtient une droite de tendance montrant clairement la relation linÃ©aire entre le poids et la consommation :
        - Les points bleus reprÃ©sentent les donnÃ©es rÃ©elles (poids vs consommation).
        - La ligne rouge est la droite de rÃ©gression linÃ©aire ajustÃ©e par le modÃ¨le.

        ---

        ### Visualisation des cylindres

        Colorons les points en fonction du nombre de cylindres pour voir si on peut observer une tendance supplÃ©mentaire :

        ```python
        for cyl in [8, 6, 5, 4, 3]:              # pour chaque nombre de cylindres
            subset = df[df["cylinders"] == cyl]  # on crÃ©e un dataframe filtrÃ© pour ce nombre de cylindres
            # puis on trace les points correspondants :
            plt.scatter(subset["weight"], subset["l_par_100km"], alpha=0.6, label=f"{cyl} cylindres")

        plt.xlabel("Poids du vÃ©hicule (lbs)")
        plt.ylabel("Consommation d'essence (L/100km)")
        plt.title("Consommation en fonction du poids selon le nombre de cylindres")
        plt.legend()

        plt.show()
        ```
        <img src={require('/img/cours/r11_poids_vs_conso_3.png').default} width="50%"/>
        ğŸ’¬ On observe que les voitures avec plus de cylindres (ex. 8 cylindres) ont tendance Ã  Ãªtre plus lourdes et Ã  consommer plus dâ€™essence, ce qui confirme notre analyse prÃ©cÃ©dente.

        ---

        ### âš™ï¸ RÃ©gression multiple

        On peut facilement ajouter dâ€™autres variables (ex. nombre de cylindres, puissance) :

        ```python
        # Suppression des valeurs manquantes pour les colonnes utilisÃ©es
        df = df.dropna(subset=["l_par_100km", "weight", "cylinders", "horsepower"])

        # PrÃ©paration des variables X et y
        X = df[["weight", "cylinders", "horsepower"]]
        y = df["l_par_100km"]

        # ModÃ¨le de rÃ©gression
        model_multi = LinearRegression().fit(X, y)

        print("Coefficients :", model_multi.coef_)
        print("Score RÂ² :", model_multi.score(X, y))
        print("Intercept :", model_multi.intercept_)
        ```
        ```
        Coefficients : [0.00229432 0.2757425  0.03284566]
        Score RÂ² : 0.8176921365228299
        Intercept : -0.5232093212414135
        ```
        - Le score RÂ² a augmentÃ© Ã  0.82, indiquant que lâ€™ajout de ces variables amÃ©liore la capacitÃ© du modÃ¨le Ã  expliquer la variance de la consommation.
        - La relation reste positive pour le poids et le nombre de cylindres, et la puissance a aussi un effet positif sur la consommation.
        - La formule de la rÃ©gression multiple est donc :
        $$
        \text{l\_par\_100km} \quad = \quad 0.00229 \times \text{weight} \quad + \quad 0.2757 \times \text{cylinders} \quad + \quad 0.03285 \times \text{horsepower} \quad - \quad 0.5232
        $$

        ---

        ### ğŸ§  Ã€ retenir

        | Objectif | Outil |
        |-----------|-------|
        | Charger et explorer les donnÃ©es | ğŸ¼ Pandas |
        | Visualiser les relations | ğŸ“Š Matplotlib |
        | ModÃ©liser une tendance | ğŸ¤– Scikit-learn (LinearRegression) |

        Au prochain cours, nous verrons comment utiliser Scikit-learn pour des tÃ¢ches plus avancÃ©es, notamment l'apprentissage machine (*machine learning*) et l'apprentissage profond (*deep learning*). ğŸ¯

        :::

    </TabItem>

    <TabItem value="exercices" label="Exercices">

        ## âœï¸ Exercices de comprÃ©hension

        :::info Exercice -

        :::

        ## ğŸ”¨ Exercices de crÃ©ation

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        :::info Exercice -

        :::

        :::info Exercice -

        :::

    </TabItem>

</Tabs>
