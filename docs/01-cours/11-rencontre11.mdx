---
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import useBaseUrl from '@docusaurus/useBaseUrl';

# üêº Pandas et ü§ñ Scikit-learn

# üèóÔ∏è en construction üèó

<Tabs queryString="onglet">

    <TabItem value="data" label="Analyse de donn√©es" default>

        :::tip üí° Introduction √† l'analyse de donn√©es

        üìä Pour votre **TP2**, vous allez devoir manipuler des **donn√©es r√©elles** :

        - üì• Charger des ensembles de donn√©es √† partir de fichiers **CSV**.
        - üßπ **Nettoyer et pr√©traiter** les donn√©es pour les rendre exploitables.
        - üîç **Analyser** les donn√©es pour en extraire des informations pertinentes.
        - üìà **Visualiser** les donn√©es √† l'aide de graphiques.
        - ü§ñ Utiliser des techniques d‚Äô**apprentissage automatique** pour construire des mod√®les pr√©dictifs.

        üß† Cela n√©cessite une bonne compr√©hension des **concepts** et des **outils d‚Äôanalyse de donn√©es**.

        ---

        üî¨ L‚Äô**analyse de donn√©es** est un processus essentiel qui consiste √† examiner, nettoyer, transformer et mod√©liser des donn√©es dans le but de **d√©couvrir des informations utiles**, **informer des conclusions** et **soutenir la prise de d√©cision**.

        ---

        üß∞ **Biblioth√®ques Python couramment utilis√©es** pour l‚Äôanalyse de donn√©es :

        - üêº **Pandas** : pour la **manipulation et l‚Äôanalyse** de donn√©es, offrant des structures de type *DataFrame*.
        - üî¢ **NumPy** : pour le **calcul scientifique** et les op√©rations sur des tableaux multidimensionnels.
        - ü§ñ **Scikit-learn** : pour l‚Äô**apprentissage automatique** et la mod√©lisation pr√©dictive.
        - üß† **Keras** et **TensorFlow** : pour le d√©veloppement de mod√®les d‚Äô**apprentissage profond** (*deep learning*).
        - üé® **Matplotlib** et **Seaborn** : pour la **visualisation** de donn√©es.
        - ‚Ä¶ et bien d‚Äôautres selon les besoins !

        ---

        üß© Vous connaissez d√©j√† :
        - üé® **Matplotlib** pour la **visualisation**
        - üî¢ **NumPy** pour les **calculs num√©riques**

        üìÖ Cette semaine, nous allons apprendre √† utiliser deux nouvelles biblioth√®ques essentielles pour votre TP2 :
        üêº **Pandas** et ü§ñ **Scikit-learn**.<br />
        üëâ La semaine prochaine, nous aborderons les concepts d‚Äô**intelligence artificielle** et d‚Äô**apprentissage profond** (*deep learning*).

        :::

    </TabItem>

    <TabItem value="pandas" label="üêº Pandas">

        :::info Introduction √† üêº Pandas

        Pandas est une biblioth√®que Python essentielle pour la manipulation et l'analyse de donn√©es. Elle offre des structures de donn√©es flexibles et performantes, telles que les *DataFrames*, qui facilitent le traitement des donn√©es tabulaires.

        :::

        ---

        :::info Le DataFrame

        Le **DataFrame** est la structure de donn√©es principale de Pandas. Il s'agit d'une table bidimensionnelle, similaire √† une feuille de calcul Excel, o√π les donn√©es sont organis√©es en lignes et en colonnes. Chaque colonne peut contenir des types de donn√©es diff√©rents (nombres, cha√Ænes de caract√®res, dates, etc.).

        On peut cr√©er un DataFrame √† partir de diverses sources de donn√©es, telles que des fichiers CSV, des bases de donn√©es SQL, ou m√™me des dictionnaires Python.

        :::

        ---

        :::info Cr√©ation d'un DataFrame √† partir d'un dictionnaire
        ```python
        import pandas as pd

        # Cr√©ation d'un DataFrame √† partir d'un dictionnaire
        data = {'Nom': ['Alice', 'Bob', 'Charlie'],
                '√Çge': [25, 30, 35],
                'Ville': ['Paris', 'Lyon', 'Marseille']}
        df = pd.DataFrame(data)

        # Affichage du DataFrame
        print(df)
        ```
        Cela produira le DataFrame suivant :
        ```
               Nom  √Çge      Ville
        0    Alice   25      Paris
        1      Bob   30       Lyon
        2  Charlie   35  Marseille
        ```
        - Les cl√©s du dictionnaire deviennent les noms des colonnes, et chaque liste associ√©e √† une cl√© devient une colonne de donn√©es.
        - La premi√®re colonne (0, 1, 2) est l'index par d√©faut des lignes.
        - La premi√®re ligne repr√©sente les en-t√™tes des colonnes.
        - Chaque ligne suivante repr√©sente un enregistrement (une personne dans cet exemple).

        :::

        ---

        :::info Lire un fichier CSV avec Pandas

        Le fichier <a href={useBaseUrl('/ressources/csv/tips_dataset.csv')} download="tips_dataset.csv">tips_dataset.csv</a> contient des donn√©es sur les pourboires donn√©s dans un restaurant, les colonnes suivantes : le montant total de la facture, le pourboire, le sexe du serveur, si le client est fumeur, le jour de la semaine, le moment de la journ√©e (d√Æner/*lunch* ou souper/*dinner*) et la taille du groupe :

        ```csv
        total_bill,tip,sex,smoker,day,time,size
        16.99,1.01,Female,No,Sun,Dinner,2
        10.34,1.66,Male,No,Sun,Dinner,3
        21.01,3.5,Male,No,Sun,Dinner,3
        23.68,3.31,Male,No,Sun,Dinner,2
        ...
        ```
        Si vous le <a href={useBaseUrl('/ressources/csv/tips_dataset.csv')} download="tips_dataset.csv">t√©l√©chargez</a> et le placez dans votre projet Pycharm, vous pouvez le lire avec Pandas comme ceci :
        ```python
        import pandas as pd

        # Lire le fichier CSV dans un DataFrame
        df = pd.read_csv('tips_dataset.csv')

        # Afficher les premi√®res lignes du DataFrame
        print(df.head())
        ```
        Cela produira un DataFrame qui ressemble √† ceci (seules les 5 premi√®res lignes sont affich√©es) :
        ```
           total_bill   tip     sex smoker  day    time  size
        0       16.99  1.01  Female     No  Sun  Dinner     2
        1       10.34  1.66    Male     No  Sun  Dinner     3
        2       21.01  3.50    Male     No  Sun  Dinner     3
        3       23.68  3.31    Male     No  Sun  Dinner     2
        4       24.59  3.61  Female     No  Sun  Dinner     4
        ```
        Nous utiliserons ces donn√©es pour illustrer diverses op√©rations avec Pandas.
        - Chargez-les et exp√©rimentez par vous-m√™me ! üéØ

        :::

        ---

        ::::info Op√©rations cl√©s avec üêº Pandas

        Une fois vos donn√©es charg√©es dans un DataFrame, vous pouvez effectuer une grande vari√©t√© d‚Äôop√©rations pour les explorer, les transformer et en extraire de l‚Äôinformation utile.

        Voici quelques exemples pratiques avec le DataFrame `df` du fichier **tips_dataset.csv** :

        ---

        ### üëÄ Afficher et explorer les donn√©es

        ```python
        # Affiche les 5 premi√®res lignes du DataFrame
        print(df.head())

        # Affiche les informations sur les colonnes et les types de donn√©es
        df.info()

        # Affiche des statistiques descriptives (moyenne, min, max, etc.)
        print(df.describe())
        ```
        Cette derni√®re commande `df.describe()` permet d‚Äôobtenir sous forme d'un DataFrame un r√©sum√© statistique rapide des colonnes num√©riques du DataFrame, incluant des mesures telles que la moyenne (mean), l‚Äô√©cart-type (std), les valeurs minimales (min) et maximales (max), ainsi que les quartiles (25%, 75%, 75%) :
        ```
               total_bill         tip        size
        count  244.000000  244.000000  244.000000
        mean    19.785943    2.998279    2.569672
        std      8.902412    1.383638    0.951100
        min      3.070000    1.000000    1.000000
        25%     13.347500    2.000000    2.000000
        50%     17.795000    2.900000    2.000000
        75%     24.127500    3.562500    3.000000
        max     50.810000   10.000000    6.000000
        ```

        ---

        ### üîç R√©cup√©rer le contenu d'une ligne et d'une colonne en particulier

        On peut r√©cup√©rer par programmation le contenu sp√©cifique d'un DataFrame √† l'aide de la m√©thode `loc`. \
        Cette m√©thode permet de r√©cup√©rer le contenu √† une ligne et une colonne sp√©cifi√©e :

        ```python
        # R√©sum√© statistique
        desc = df.describe()

        # Extraire la moyenne de la colonne 'tip'
        mean_tip = desc.loc['mean', 'tip']
        print("Moyenne de tip :", mean_tip) #2.998279
        ```


        ---

        ### üéØ S√©lectionner des colonnes et des lignes

        Il est possible de cr√©er un nouveau DataFrame √† partir d'un DataFrame existant ayant que certaines colonnes ou certaines lignes :

        ```python
        # Cr√©er un nouveau DataFrame que la colonne "total_bill"
        df_total_bill = df["total_bill"]
        print(df)

        # Cr√©er un nouveau DataFrame avec 3 des colonnes
        df_plusieurs_colonnes = df[["total_bill", "tip", "day"]]
        print(df_plusieurs_colonnes)

        # Cr√©er un nouveau DataFrame avec la ligne 4 uniquement
        df_une_seule_ligne = df.iloc[3]  # 4√®me ligne (index 3)
        print(df_une_seule_ligne)

        # Cr√©er un nouveau DataFrame avec les lignes 4 √† 9
        df_plusieurs_lignes = df.iloc[3:10]
        print(df_plusieurs_lignes)
        ```

        Prenez le temps d'observer √† l'aide de PyCharm le contenu afficher √† l'aide des prints :
        - Si un DataFrame contient qu'une colonne le nom de la colonne est retir√© (ex : df_total_bill)
        - Si un DataFrame contient qu'une seule ligne, l'affichage est diff√©rent (ex : df_une_seule_ligne)

        :::warning Attention
        Toutes ces op√©rations (et celles qui suivent) **ne modifient pas** le DataFrame original `df`. \
        Elles renvoient un **nouveau DataFrame** bas√© sur les crit√®res sp√©cifi√©s. Il est cependant possible de stocker le r√©sultat dans une nouvelle variable si besoin :
        ```python
        df_filtered = df[df["tip"] > 5]
        ```
        `df_filtered` contiendra alors un nouveau DataFrame avec uniquement les lignes o√π le pourboire est sup√©rieur √† 5.
        :::

        ---

        ### üîç Filtrer les donn√©es

        Il est possible de cr√©er un nouveau DataFrame filtrant (retirant) des lignes :


        ```python
        # Filtrer les lignes o√π le pourboire est sup√©rieur √† 5
        df_filtre1 = df[df["tip"] > 5]
        print(df_filtre1)

        # Filtrer les lignes pour le jour "Sun" et le temps "Dinner"
        df_filtre2 = df[(df["day"] == "Sun") & (df["time"] == "Dinner")]
        print(df_filtre2)

        # Filtrer les lignes o√π le serveur est une femme et le pourboire sup√©rieur √† 3
        df_filtre3 = df[(df["sex"] == "Female") & (df["tip"] > 3)]
        print(df_filtre3)
        ```

        ---

        ### üìà Trier et ordonner les donn√©es

        Il est possible de cr√©er un nouveau DataFrame tri√© sur une ou plusieurs colonnes :

        ```python
        # Trier par montant total de la facture (total_bill) en ordre croissant
        df_trie1 = df.sort_values(by="total_bill")
        print(df_trie1)

        # Trier par pourboire (tip) en ordre d√©croissant
        df_trie2 = df.sort_values(by="tip", ascending=False)
        print(df_trie2)

        # Trier par jour puis par montant total de la facture
        df_trie3 = df.sort_values(by=["day", "total_bill"])
        print(df_trie3)
        ```

        ---

        ### üßÆ Cr√©er de nouvelles colonnes

        Parfois, nous souhaitons cr√©er de nouvelles colonnes dans un DataFrame bas√©es sur le contenu de colonnes d√©j√† pr√©sentes

        ```python
        # Ajouter une colonne pour le pourcentage de pourboire
        df["tip_percentage"] = (df["tip"] / df["total_bill"]) * 100
        ```
        Cela ajoute une nouvelle colonne `tip_percentage` au DataFrame, calculant le pourcentage de pourboire par rapport au montant total de la facture :
        ```
           total_bill   tip     sex smoker  day    time  size  tip_percentage
        0       16.99  1.01  Female     No  Sun  Dinner     2        5.944673
        1       10.34  1.66    Male     No  Sun  Dinner     3       16.054159
        2       21.01  3.50    Male     No  Sun  Dinner     3       16.658734
        3       23.68  3.31    Male     No  Sun  Dinner     2       13.978041
        4       24.59  3.61  Female     No  Sun  Dinner     4       14.680765
        ```

        ---

        ### üß† Statistiques et agr√©gations

        Il est possible de calculer des statistiques sur une colonne ou sur une agr√©gation :

        ```python
        # Moyenne du pourboire
        tip_moyen = df["tip"].mean()
        print(tip_moyen) # affiche 2.99827868852459

        # Moyenne du pourboire par jour
        df_tip_jour = df.groupby("day")["tip"].mean()
        print(df_tip_jour)
        ```
        Cela produira une sortie similaire √† :
        ```
        day
        Fri     2.734737
        Sat     2.993103
        Sun     3.255132
        Thur    2.771452
        Name: tip, dtype: float64
        ```
        On voit que c'est plus payant le dimanche ! üòâ

        ---

        ### üîÅ Parcourir ligne par ligne

        Tu peux parcourir un DataFrame de pandas de diff√©rentes mani√®res. \
        La mani√®re la plus simple est d'utiliser la m√©thode `iterrows()` et une boucle for :

        ```python
        import pandas as pd

        #Cr√©ation d'un DataFrame
        df = pd.DataFrame({
            'Nom': ['Alice', 'Bob', 'Charlie'],
            'Age': [25, 30, 35]
        })

        #Boucle sur ce DataFrame
        for index, row in df.iterrows():
            print(f"Index: {index}, Nom: {row['Nom']}, Age: {row['Age']}")
        ```

        ---

        ### üßπ Nettoyage de donn√©es

        Il peut arriver que le contenu de lignes ou colonnes soit manquant. \
        On souhaite g√©n√©ralement retirer ces lignes pour √©viter des probl√®mes avant nos analyses.

        ```python
        # Supprimer les lignes avec des valeurs manquantes
        df_clean = df.dropna()
        ```

        ---

        ### üìä Visualisation rapide (avec Matplotlib int√©gr√©)

        Pandas s'int√®gre avec Matplotlib pour g√©n√©rer rapidement des graphiques bas√© sur vos DataFrames :

        ```python
        import pandas as pd
        import matplotlib.pyplot as plt

        # Lire le fichier CSV dans un DataFrame
        df = pd.read_csv('tips_dataset.csv')

        # Ajouter une colonne pour le pourcentage de pourboire
        df["tip_percentage"] = (df["tip"] / df["total_bill"]) * 100

        # Histogramme du pourcentage de pourboire
        df["tip_percentage"].plot(kind="hist", bins=20, title="Distribution du pourcentage de pourboire")
        plt.xlabel("Pourcentage de pourboire")
        plt.ylabel("Fr√©quence")
        plt.grid(which='both', linestyle='--', linewidth=0.5)
        plt.show()

        # Bo√Æte √† moustaches du pourcentage de pourboire par jour
        df.boxplot(column="tip_percentage", by="day", grid=False)
        plt.title("Pourcentage de pourboire par jour")
        plt.suptitle("")  # Supprimer le titre par d√©faut
        plt.xlabel("Jour")
        plt.ylabel("Pourcentage de pourboire")
        plt.grid(which='both', linestyle='--', linewidth=0.5)
        plt.show()
        ```

        <Row>
          <Column size={6}>
            <div style={{ textAlign: "left" }}>
              <img
                src={require('/img/cours/r11_histogramme_pourcentage_pourboire.png').default}
                alt="Histogramme des pourboires"
                style={{ maxWidth: '100%', height: 'auto' }}
              />
            </div>
          </Column>

          <Column size={6}>
            <div style={{ textAlign: "right" }}>
              <img
                src={require('/img/cours/r11_boxplot_pourcentage_pourboire_par_jour.png').default}
                alt="Boxplot pourcentage pourboire par jour"
                style={{ maxWidth: '100%', height: 'auto' }}
              />
            </div>
          </Column>
        </Row>

        ---

        üí° **En r√©sum√© :**
        - `df.head()` ‚ûú aper√ßu rapide
        - `df[...]` ‚ûú s√©lection ou filtrage
        - `df.sort_values()` ‚ûú tri
        - `df.groupby()` ‚ûú regroupement et statistiques
        - `df.plot()` ‚ûú visualisation rapide

        Pandas vous permet de passer **d‚Äôun simple fichier CSV √† une analyse compl√®te** en quelques lignes seulement. üéØ

        ::::

    </TabItem>

    <TabItem value="learn" label="ü§ñ Scikit-learn">

        :::info Introduction √† ü§ñ Scikit-learn

        Scikit-learn est une biblioth√®que Python puissante pour l'apprentissage automatique. Elle fournit des outils simples et efficaces pour la mod√©lisation pr√©dictive, c'est √† dire la cr√©ation de mod√®le capable d'identifier des sch√©mas dans les donn√©es pour √™tre en mesure de r√©aliser des pr√©dictions de r√©sultat. 3 types d'algorithmes sont utilis√© :
        - de classification, pour classer des √©l√©ments <i>(ex : ceci est une photo de chat, ceci est une photo de chien)</i>
        - de r√©gression, pour pr√©dire des valeurs <i>(ex : combien de Bixi devrait √™tre emprunt√© demain)</i>
        - de clustering, pour g√©n√©r√© des regroupements <i>(ex : faire des regroupements de clients ayant des habitudes d'achat similaire)</i>


        ### Concepts cl√©s de Scikit-learn
        - **Mod√®les** : Scikit-learn propose une large gamme d'algorithmes d'apprentissage automatique.
        - **Pr√©traitement des donn√©es** : La biblioth√®que offre des outils pour normaliser, standardiser et encoder les donn√©es avant de les utiliser dans des mod√®les.
        - **√âvaluation des mod√®les** : Scikit-learn fournit des m√©triques pour √©valuer la performance des mod√®les et leur niveau fiabilit√©.
        - **Pipeline** : Permet de cha√Æner plusieurs √©tapes de traitement et de mod√©lisation en un seul objet.

        üëâ Cette semaine, nous allons nous concentrer sur l'utilisation de Scikit-learn pour des t√¢ches simples de r√©gression, en mettant l'accent sur la visualisation des r√©sultats.

        :::

        ---

        :::info üöó D√©monstration : Consommation d‚Äôessence et caract√©ristiques des voitures

        Nous utiliserons le jeu de donn√©es classique **Auto MPG** (*Miles per Gallon*) pour explorer la relation entre la **consommation d‚Äôessence** (`mpg`) et des variables comme le **poids** (`weight`) ou le **nombre de cylindres** (`cylinders`).
        - Ce jeu de donn√©es (*dataset*) est tr√®s vintage (ann√©es 70-80 ), mais reste un excellent exemple p√©dagogique.
        - Vous pouvez le t√©l√©chargez ici : <a href={useBaseUrl('/ressources/csv/mpg_dataset.csv')} download="mpg_dataset.csv">mpg_dataset.csv</a>

        ---

        ### üß∞ Chargement du jeu de donn√©es

        ```python
        import pandas as pd

        # Chargement du jeu de donn√©es
        df = pd.read_csv('mpg_dataset.csv')

        # Aper√ßu
        print(df.head())
        df.info()
        ```
        ```
            mpg  cylinders  displacement  ...  model_year  origin                       name
        0  18.0          8         307.0  ...          70     usa  chevrolet chevelle malibu
        1  15.0          8         350.0  ...          70     usa          buick skylark 320
        2  18.0          8         318.0  ...          70     usa         plymouth satellite
        3  16.0          8         304.0  ...          70     usa              amc rebel sst
        4  17.0          8         302.0  ...          70     usa                ford torino

        [5 rows x 9 columns]

        RangeIndex: 398 entries, 0 to 397
        Data columns (total 9 columns):
         #   Column        Non-Null Count  Dtype
        ---  ------        --------------  -----
         0   mpg           398 non-null    float64
         1   cylinders     398 non-null    int64
         2   displacement  398 non-null    float64
         3   horsepower    392 non-null    float64
         4   weight        398 non-null    int64
         5   acceleration  398 non-null    float64
         6   model_year    398 non-null    int64
         7   origin        398 non-null    object
         8   name          398 non-null    object
        dtypes: float64(4), int64(3), object(2)
        memory usage: 28.1+ KB
        ```
        Ce jeu de donn√©es contient 398 entr√©es (voitures) avec les 9 colonnes suivantes :
        1. `mpg` : consommation en miles par gallon
        2. `cylinders` : nombre de cylindres
        3. `displacement` : cylindr√©e en pouces cubes
        4. `horsepower` : puissance en chevaux
        5. `weight` : poids en livres
        6. `acceleration` : temps d‚Äôacc√©l√©ration de 0 √† 60 mph
        7. `model_year` : ann√©e du mod√®le
        8. `origin` : pays d‚Äôorigine (usa, europe, japan)
        9. `name` : nom du mod√®le

        Ce qui nous int√©resse ici, c‚Äôest de voir comment certaines caract√©ristiques (ex. poids, cylindres) influencent la consommation (`mpg`, premi√®re colonne).

        ---

        ### üîç Exploration rapide

            Regroupons les voitures par nombre de cylindres et calculons la moyenne de consommation pour chaque groupe :
        ```python
        # Moyenne de la consommation par nombre de cylindres
        print(df.groupby("cylinders")["mpg"].mean())
        ```
        ```
        cylinders
        3    20.550000
        4    29.286765
        5    27.366667
        6    19.985714
        8    14.963107
        Name: mpg, dtype: float64
        ```
        üí° On observe une relation **inverse** : √† l'exception des petits 3-cylindres, on dirait que plus il y a de cylindres, plus la mesure de consommation (mpg) diminue. ü§î<br />
            C'est plut√¥t logique : plus une voiture a de cylindres, plus elle consomme d‚Äôessence (donc moins elle parcourt de miles par gallon).
            Mais c'est un peu m√©langeant, car on est plut√¥t habitu√© √† penser √† l'envers, soit en litres consomm√©s aux 100 km (L/100km), o√π une consommation plus faible est donc meilleure.

        üëâ Nous allons donc cr√©er une nouvelle colonne `l_par_100km` pour convertir `mpg` en litres aux 100 km :
        ```python
        # Conversion mpg -> L/100km
        df["l_par_100km"] = 235.214583 / df["mpg"]
        ```
            Refaisons le m√™me calcul avec cette nouvelle colonne :
        ```python
        print(df.groupby("cylinders")["l_par_100km"].mean())
        ```
        ```
        cylinders
        3    11.578018
        4     8.333277
        5     9.103094
        6    12.106109
        8    16.235661
        Name: l_par_100km, dtype: float64
        ```

            Visualisons maintenant la relation entre le poids (`weight`) et la consommation (`l_par_100km`) avec un graphique de dispersion (`scatter plot`) :
        ```python
        # Visualisation simple
        import matplotlib.pyplot as plt

        plt.scatter(df["weight"], df["l_par_100km"], alpha=0.6)

        plt.xlabel("Poids du v√©hicule (lbs)")
        plt.ylabel("Consommation d'essence (L/100km)")
        plt.title("Consommation d'essence en fonction du poids du v√©hicule")

        plt.show()
        ```
        <img src={require('/img/cours/r11_poids_vs_conso_1.png').default} width="50%"/>

        <br /><br />

        üí¨ On observe une tendance claire : plus le poids du v√©hicule augmente, plus la consommation en litres aux 100 km augmente √©galement. Cela confirme notre intuition que les voitures plus lourdes consomment plus d‚Äôessence.

        ---

        ### üßÆ R√©gression lin√©aire simple (Scikit-learn)

        Nous allons mod√©liser cette relation avec une r√©gression lin√©aire (`LinearRegression`).

            Pr√©parons d'abord les donn√©es :
        ```python
        # Suppression les lignes dont des valeurs sont manquantes (on regarde seulement les colonnes utilis√©es : l_par_100km et weight)
        df = df.dropna(subset=["l_par_100km", "weight"])

        # Pr√©paration des variables
        X = df[["weight"]]            # variables explicatives (des variables ayant une influence pour la d√©termination de la pr√©diction)
        y = df["l_par_100km"]         # variable cible (la variable pour laquelle on tente de pr√©dire un r√©sultat)
        ```

        Il est tr√®s important de bien comprendre ici la structure de `X` et `y` :
        - `X` est un DataFrame √† 2 dimensions (double `[` et double `]`) m√™me si une seule colonne : il doit toujours √™tre en 2D pour Scikit-learn.
        - `y` est une Series (1D) contenant les valeurs cibles.

        Ici :
        - `X` est une matrice 2D de dimensions (n_samples, n_features) o√π `n_samples` est le nombre de voitures et `n_features` est 1 (le poids).
        - `y` est un vecteur 1D de longueur `n_samples` contenant les valeurs de consommation (l_par_100km).

        Plus pr√©cis√©ment, comme on a 398 voitures, `X` aura une forme (398, 1) et `y` aura une forme (398,) :
        <Row>
            <Column>
                ```python
                print(X)
                ```
                ```
                     weight
                0      3504
                1      3693
                2      3436
                3      3433
                4      3449
                ..      ...
                393    2790
                394    2130
                395    2295
                396    2625
                397    2720

                [398 rows x 1 columns]
                ```
            </Column>
            <Column>
                ```python
                print(y)
                ```
                ```

                0      13.067477
                1      15.680972
                2      13.067477
                3      14.700911
                4      13.836152
                         ...
                393     8.711651
                394     5.345786
                395     7.350456
                396     8.400521
                397     7.587567
                Name: l_par_100km, Length: 398, dtype: float64

                ```
            </Column>
        </Row>

        Entra√Ænons maintenant le mod√®le de r√©gression lin√©aire :
        ```python
        from sklearn.linear_model import LinearRegression

        # Mod√®le lin√©aire
        model = LinearRegression().fit(X, y) # c'est ici que le mod√®le travaille
                                             # pour apprendre la relation entre X et y

        print("Score R¬≤ :", model.score(X, y))
        print("Coefficient :", model.coef_[0])
        print("Intercept :", model.intercept_)
        ```
        ```
        Score R¬≤ : 0.7836118983544517
        Coefficient : 0.0040789144329788085
        Intercept : -0.9030520509041988
        ```
        - Un score R¬≤ de 0.78 indique que le mod√®le explique environ 78% de la variance observ√©e dans la consommation (`l_par_100km`) en fonction du poids
            - R¬≤ repr√©sente une forte relation lin√©aire (tr√®s bon).
            - Un score **R¬≤ = 1** : Le mod√®le explique parfaitement la variance des donn√©es (**Parfait**)
            - Un score **0.7 ‚â§ R¬≤ < 1** : Le mod√®le explique bien la variance, mais pas parfaitement (**Tr√®s bon**)
            - Un score **0.5 ‚â§ R¬≤ < 0.7** : Le mod√®le explique une partie significative de la variance (**Acceptable**)
            - Un score **0.3 ‚â§ R¬≤ < 0.5** : Le mod√®le a une faible capacit√© explicative (**M√©diocre**)
            - Un score **0 ‚â§ R¬≤ < 0.3** : Le mod√®le explique tr√®s peu de la variance (**Faible**)
            - Un score **R¬≤ = 0** : Le mod√®le n'explique rien du tout (**Inutile**)
            - Un score **R¬≤ < 0** : Le mod√®le est pire qu'une simple moyenne (r√©gression non pertinente) (**Mauvais**)

        - Le coefficient positif (0.00408) confirme que la relation est directe : **plus le poids augmente, plus la consommation (L/100km) augmente** :
            - Coefficient **positif** : la variable cible augmente quand la variable explicative augmente.
            - Coefficient **n√©gatif** : la variable cible diminue quand la variable explicative augmente.
            - Coefficient **proche de z√©ro** : la variable explicative a peu ou pas d‚Äôeffet.

        - La relation entre le poids et la consommation peut donc √™tre mod√©lis√©e par la formule de la droite de r√©gression suivante :
        $$
        \text{l\_par\_100km} \quad = \quad 0.00408 \times \text{weight} - 0.903
        $$


        <p align="center">(o√π 0.00408 est la valeur du coefficient et -0.903 est la valeur intercept)</p>

        ---

        ### üìà Visualisation de la r√©gression

        La m√©thode `model.predict()` permet d'obtenir les valeurs cibles pr√©dites par le mod√®le (<i>√† l'aide de la formule</i>).


        ```python
        plt.scatter(X, y, label="Donn√©es r√©elles", alpha=0.6)

        # On ajoute la droite de r√©gression :
        plt.plot(X, model.predict(X), color="red", label="R√©gression lin√©aire")

        plt.xlabel("Poids du v√©hicule (lbs)")
        plt.ylabel("Consommation d'essence (L/100km)")
        plt.title("R√©gression lin√©aire : Poids vs Consommation")
        plt.legend()

        plt.show()
        ```
        <img src={require('/img/cours/r11_poids_vs_conso_2.png').default} width="50%"/>

        <br /><br />

        üí¨ On obtient une droite de tendance montrant clairement la relation lin√©aire entre le poids et la consommation :
        - Les points bleus repr√©sentent les donn√©es r√©elles (poids vs consommation).
        - La ligne rouge est la droite de r√©gression lin√©aire ajust√©e par le mod√®le.

        ---

        ### Visualisation des cylindres

        Colorons les points en fonction du nombre de cylindres pour voir si on peut observer une tendance suppl√©mentaire :

        ```python
        for cyl in [8, 6, 5, 4, 3]:              # pour chaque nombre de cylindres
            subset = df[df["cylinders"] == cyl]  # on cr√©e un dataframe filtr√© pour ce nombre de cylindres
            # puis on trace les points correspondants :
            plt.scatter(subset["weight"], subset["l_par_100km"], alpha=0.6, label=f"{cyl} cylindres")

        plt.xlabel("Poids du v√©hicule (lbs)")
        plt.ylabel("Consommation d'essence (L/100km)")
        plt.title("Consommation en fonction du poids selon le nombre de cylindres")
        plt.legend()

        plt.show()
        ```
        <img src={require('/img/cours/r11_poids_vs_conso_3.png').default} width="50%"/>

        <br /><br />

        üí¨ On observe que les voitures avec plus de cylindres (ex. 8 cylindres) ont tendance √† √™tre plus lourdes et √† consommer plus d‚Äôessence, ce qui confirme notre analyse pr√©c√©dente.

        ---

        ### ‚öôÔ∏è R√©gression multiple

        On peut facilement ajouter d‚Äôautres variables (ex. nombre de cylindres, puissance) :

        ```python
        # Suppression des valeurs manquantes pour les colonnes utilis√©es
        df = df.dropna(subset=["l_par_100km", "weight", "cylinders", "horsepower"])

        # Pr√©paration des variables X et y
        X = df[["weight", "cylinders", "horsepower"]]
        y = df["l_par_100km"]

        # Mod√®le de r√©gression
        model_multi = LinearRegression().fit(X, y)

        print("Coefficients :", model_multi.coef_)
        print("Score R¬≤ :", model_multi.score(X, y))
        print("Intercept :", model_multi.intercept_)
        ```
        ```
        Coefficients : [0.00229432 0.2757425  0.03284566]
        Score R¬≤ : 0.8176921365228299
        Intercept : -0.5232093212414135
        ```
        - Le score R¬≤ a augment√© √† 0.82, indiquant que l‚Äôajout de ces variables am√©liore la capacit√© du mod√®le √† expliquer la variance de la consommation.
        - La relation reste positive pour le poids et le nombre de cylindres, et la puissance a aussi un effet positif sur la consommation.
        - La formule de la r√©gression multiple est donc :
        $$
        \text{l\_par\_100km} \quad = \quad 0.00229 \times \text{weight} \quad + \quad 0.2757 \times \text{cylinders} \quad + \quad 0.03285 \times \text{horsepower} \quad - \quad 0.5232
        $$

        <p align="center">(o√π 0.00229, 0.2757 et 0.03285 sont les valeurs des coefficients de chaque variables explicatives et -0.5232 est la valeur intercept)</p>

        ---

        ### üß† √Ä retenir

        | Objectif | Outil |
        |-----------|-------|
        | Charger et explorer les donn√©es | üêº Pandas |
        | Visualiser les relations | üìä Matplotlib |
        | Mod√©liser une tendance | ü§ñ Scikit-learn (LinearRegression) |

        Au prochain cours, nous verrons comment utiliser Scikit-learn pour des t√¢ches plus avanc√©es, \
        notamment l'apprentissage machine (*machine learning*) et l'apprentissage profond (*deep learning*). üéØ

        :::

    </TabItem>

    <TabItem value="exercices" label="Exercices">

        ## ‚úèÔ∏è Exercices de compr√©hension

        :::info Exercice -

        :::

        ## üî® Exercices de cr√©ation

        :::info Exercice - groupby et moyenne

        T√©l√©chargez le fichier <a href={useBaseUrl('/ressources/csv/tips_dataset.csv')} download="tips_dataset.csv">tips_dataset.csv</a> et utilisez üêº Pandas pour :
        1. Charger les donn√©es dans un DataFrame.
        2. Afficher les 10 premi√®res lignes.
        3. Calculer et afficher la moyenne du pourboire (`tip`) :
            1. pour les clients fumeurs et non-fumeurs,
            2. par jour de la semaine,
            3. par temps (d√Æner/lunch),
            4. par taille de groupe.

        R√©sultats attendus :
        <Row>
            <Column size={3}>
                ```
                smoker
                No     2.991854
                Yes    3.008710




                ```
            </Column>
            <Column size={3}>
                ```
                day
                Fri     2.734737
                Sat     2.993103
                Sun     3.255132
                Thur    2.771452


                ```
            </Column>
            <Column size={3}>
                ```
                time
                Dinner    3.102670
                Lunch     2.728088




                ```
            </Column>
            <Column size={3}>
                ```
                size
                1    1.437500
                2    2.582308
                3    3.393158
                4    4.135405
                5    4.028000
                6    5.225000
                ```
            </Column>
        </Row>

        - Quelle(s) variable(s) semble(nt) influencer le plus le montant du pourboire ?
        - Quelle(s) variable(s) semble(nt) n'avoir aucun impact ?

        :::

        :::info Exercice - nouvelle colonne et visualisation

        Toujours avec le m√™me jeu de donn√©es, cr√©ez une nouvelle colonne `tip_par_person` qui calcule le pourboire par personne (i.e. `tip` divis√© par `size`). Ensuite, affichez les 5 premi√®res lignes du DataFrame modifi√©.

        R√©sultat attendu :
        ```
           total_bill   tip     sex smoker  day    time  size  tip_par_person
        0       16.99  1.01  Female     No  Sun  Dinner     2        0.505000
        1       10.34  1.66    Male     No  Sun  Dinner     3        0.553333
        2       21.01  3.50    Male     No  Sun  Dinner     3        1.166667
        3       23.68  3.31    Male     No  Sun  Dinner     2        1.655000
        4       24.59  3.61  Female     No  Sun  Dinner     4        0.902500
        ```

        Ensuite, g√©n√©rez ces 2 graphiques :
        1. un histogramme de cette nouvelle colonne `tip_par_person` pour visualiser la distribution des pourboires par personne.
        2. un boxplot de `tip_par_person` regroup√© par taille de groupe (`size`) pour voir comment le pourboire par personne varie en fonction de la taille du groupe.

        R√©sultats attendus :
        <Row>
          <Column size={6}>
            <div style={{ textAlign: "left" }}>
              <img
                src={require('/img/cours/r11_exercice_2a.png').default}
                alt="Histogramme tip par person"
                style={{ maxWidth: '100%', height: 'auto' }}
              />
            </div>
          </Column>
            <Column size={6}>
                <div style={{ textAlign: "right" }}>
                <img
                    src={require('/img/cours/r11_exercice_2b.png').default}
                    alt="Boxplot tip par person par size"
                    style={{ maxWidth: '100%', height: 'auto' }}
                />
                </div>
            </Column>
        </Row>

        <br />

        Voyez-vous des tendances int√©ressantes ?

        :::

        :::info Exercice - Visualisation 2

        T√©l√©chargez le fichier <a href={useBaseUrl('/ressources/csv/mpg_dataset.csv')} download="mpg_dataset.csv">mpg_dataset.csv</a>.<br />
        Dans un nouveau script :
        1. Chargez les donn√©es dans un DataFrame.
        2. Cr√©ez une nouvelle colonne `l_par_100km` en convertissant `mpg` en litres aux 100 km.
        3. G√©n√©rez ces 2 graphiques :
        <Row>
          <Column size={6}>
            <div style={{ textAlign: "left" }}>
              <img
                src={require('/img/cours/r11_exercice_3a.png').default}
                alt="Histogramme tip par person"
                style={{ maxWidth: '100%', height: 'auto' }}
              />
            </div>
          </Column>
            <Column size={6}>
                <div style={{ textAlign: "right" }}>
                <img
                    src={require('/img/cours/r11_exercice_3b.png').default}
                    alt="Boxplot tip par person par size"
                    style={{ maxWidth: '100%', height: 'auto' }}
                />
                </div>
            </Column>
        </Row>

        <br />

        Voyez-vous des tendances int√©ressantes ?

        :::

        :::info Exercice -

        utilisez üêº Pandas et ü§ñ Scikit-learn pour :

        :::

    </TabItem>

</Tabs>
