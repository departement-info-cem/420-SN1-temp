---
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# ğŸ¤– Intelligence artificielle, TP2

# ğŸ—ï¸ en construction ğŸ—

<Tabs queryString="onglet">

    <TabItem value="ia" label="ğŸ¤– Intelligence artificielle" default>

        :::info ğŸ¤– Qu'est-ce que l'IA?
        L'intelligence artificielle (IA) est un domaine de l'informatique visant Ã  crÃ©er des systÃ¨mes capables d'effectuer des tÃ¢ches qui nÃ©cessitent normalement l'intelligence humaine, telles que la reconnaissance vocale, la vision par ordinateur, la prise de dÃ©cision et le traitement du langage naturel.

        Dans les derniÃ¨res annÃ©es, l'utilisation d'outils basÃ©s sur l'IA, comme les modÃ¨les de langage (ex: ChatGPT), s'est largement dÃ©mocratisÃ©e, rendant ces technologies accessibles Ã  un public plus large. Cela a stimulÃ© un intÃ©rÃªt accru pour l'IA et intensifiÃ© son dÃ©veloppement. Cependant, cette popularisation a Ã©galement permis de mieux comprendre les capacitÃ©s et les limites de l'IA, tout en soulevant des questions Ã©thiques et sociÃ©tales importantes.
        :::

        :::tip ğŸ“œ Bref historique
        Ã‡a a Ã©tÃ© inventÃ© hier, l'intelligence artificielle?<br />
        Non, pas vraiment!<br />
        L'IA a une histoire riche qui remonte aux annÃ©es 1950, avec des avancÃ©es majeures dans les dÃ©cennies suivantes. Voici un aperÃ§u des principales Ã©tapes de son Ã©volution :

        | PÃ©riode | Jalons | IdÃ©e dominante |
        |---------|--------|----------------|
        | 1950â€“1960 | Test de Turing, Dartmouth 1956 | Symbolisme, logique |
        | 1970â€“1980 | SystÃ¨mes experts | RÃ¨gles si-alors |
        | 1990â€“2005 | Renaissance de l'apprentissage statistique | DonnÃ©es + optimisation |
        | 2012â€“2020 | Explosion du deep learning (ImageNet) | RÃ©seaux profonds |
        | 2020+ | ModÃ¨les fondamentaux (LLM), efficience | ScalabilitÃ©, coÃ»t Ã©nergÃ©tique |

        - Pour la petite histoire, durant la Seconde Guerre mondiale, Alan Turing a dÃ©veloppÃ© des concepts fondamentaux en informatique et en cryptographie, afin de dÃ©chiffrer les codes ennemis des machines Enigma des Allemands. AprÃ¨s la guerre, il a proposÃ© en 1950 un test pour Ã©valuer l'intelligence d'une machine, et le terme *intelligence artificielle* a Ã©tÃ© officiellement introduit lors de la confÃ©rence de Dartmouth en 1956. Depuis, l'IA a connu des pÃ©riodes d'enthousiasme et de scepticisme, mais elle est devenue un domaine central de la recherche informatique et de l'industrie technologique.

        - Les annÃ©es 2010 ont vu exploser le deep learning grÃ¢ce Ã  la disponibilitÃ© de grandes quantitÃ©s de donnÃ©es et Ã  la puissance de calcul accrue, menant Ã  des avancÃ©es spectaculaires en vision par ordinateur et en traitement du langage naturel. Aujourd'hui, l'IA continue d'Ã©voluer rapidement, avec des applications dans presque tous les secteurs industriels.

        - En 2024, l'IA gÃ©nÃ©rative, notamment les modÃ¨les de langage comme GPT-4, a rÃ©volutionnÃ© la maniÃ¨re dont les machines interagissent avec les humains, ouvrant de nouvelles perspectives et dÃ©fis pour l'avenir.
        :::

        :::info Domaines d'application
        L'IA est utilisÃ©e dans de nombreux domaines pour automatiser des tÃ¢ches, amÃ©liorer l'efficacitÃ© et offrir de nouvelles capacitÃ©s. Voici quelques exemples notables :
        | Domaine | Exemples |
        |---------|----------|
        | Vision | Reconnaissance d'objets, segmentation |
        | Langage | Traduction, agents conversationnels |
        | SantÃ© | Aide diagnostique, imagerie |
        | Sciences | Analyse donnÃ©es expÃ©rimentales |
        | Ã‰nergie | Optimisation consommation |
        :::

        :::warning Enjeux Ã©thiques
        L'IA soulÃ¨ve plusieurs enjeux Ã©thiques importants, notamment :
        - **Biais et discrimination** : Les modÃ¨les d'IA peuvent reproduire ou amplifier des biais prÃ©sents dans les donnÃ©es d'entraÃ®nement, conduisant Ã  des dÃ©cisions injustes (ex: racisme, sexisme, etc.).
        - **Vie privÃ©e** : L'utilisation de donnÃ©es personnelles pour entraÃ®ner des modÃ¨les d'IA peut compromettre la confidentialitÃ© des individus.
        - **Transparence** : Les systÃ¨mes d'IA, en particulier les modÃ¨les complexes comme les rÃ©seaux de neurones profonds, peuvent Ãªtre difficiles Ã  interprÃ©ter, rendant leurs dÃ©cisions opaques.
        - **ResponsabilitÃ©** : DÃ©terminer qui est responsable des actions d'une IA, surtout en cas d'erreur ou de prÃ©judice, est un dÃ©fi juridique et Ã©thique.
        - **Impact sur l'emploi** : L'automatisation par l'IA peut entraÃ®ner des pertes d'emplois dans certains secteurs, nÃ©cessitant une rÃ©flexion sur la reconversion professionnelle et la formation.
        :::

    </TabItem>

    <TabItem value="ml" label="ğŸ§ ğŸ§® Apprentissage machine">

        :::tip ğŸ§ ğŸ§® Qu'est-ce que l'apprentissage machine?
        L'apprentissage machine (*Machine Learning*, ML) est une branche de l'intelligence artificielle qui se concentre sur le dÃ©veloppement d'algorithmes et de modÃ¨les permettant aux ordinateurs d'apprendre Ã  partir de donnÃ©es, sans Ãªtre explicitement programmÃ©s pour chaque tÃ¢che spÃ©cifique. En utilisant des techniques statistiques, les modÃ¨les de ML identifient des patterns dans les donnÃ©es et font des prÃ©dictions ou prennent des dÃ©cisions basÃ©es sur ces patterns.
        :::

        :::info Pipeline typique d'apprentissage machine
        Voici un diagramme qui prÃ©sente les Ã©tapes clÃ©s d'un projet typique d'apprentissage machine, depuis la collecte des donnÃ©es brutes jusqu'Ã  la gÃ©nÃ©ration de prÃ©dictions Ã  l'aide d'un modÃ¨le entraÃ®nÃ© :

        <Row>
            <Column size={4}>
                ```mermaid
                flowchart TD
                A["ğŸ“¥ DonnÃ©es brutes"]
                B["ğŸ§¹ PrÃ©traitement"]
                C["ğŸ§© Extraction de caractÃ©ristiques"]
                D["ğŸ§  Choix du modÃ¨le"]
                E["ğŸ¯ EntraÃ®nement"]
                F["âœ… ModÃ¨le entraÃ®nÃ©"]
                G["ğŸ“Š Ã‰valuation"]
                H["ğŸš€ PrÃ©dictions"]
                A --> B --> C --> D --> E --> F --> G --> H
                ```
            </Column>
            <Column size={8}>
                ### ğŸ“¥ DonnÃ©es brutes
                - DonnÃ©es collectÃ©es Ã  partir de diffÃ©rentes sources : fichiers CSV, images, texte, etc.
                - Elles sont souvent incomplÃ¨tes, hÃ©tÃ©rogÃ¨nes ou bruitÃ©es.

                ### ğŸ§¹ PrÃ©traitement
                - Nettoyage : valeurs manquantes, doublons, normalisation, encodage.
                - AmÃ©liore la qualitÃ© des donnÃ©es et rÃ©duit lâ€™erreur.

                ### ğŸ§© Extraction de caractÃ©ristiques
                - Transformation des donnÃ©es en caractÃ©ristiques (*features*).
                - SÃ©lection dâ€™attributs pertinents ou crÃ©ation de nouvelles variables.

                ### ğŸ§  Choix du modÃ¨le
                - Choix de lâ€™algorithme : rÃ©gression, arbres de dÃ©cision, forÃªts, rÃ©seaux de neurones, etc.
                - Chaque modÃ¨le a ses forces et ses limites.

                ### ğŸ¯ EntraÃ®nement
                - Ajustement des paramÃ¨tres du modÃ¨le pour minimiser lâ€™erreur.
                - Inclut souvent des itÃ©rations (epochs) et une validation.
                - Peut Ãªtre exigeant en ressources (temps, mÃ©moire, Ã©nergie).

                ### âœ… ModÃ¨le entraÃ®nÃ©
                - ParamÃ¨tres optimisÃ©s et structure fixe.
                - PrÃªt Ã  Ãªtre Ã©valuÃ© sur des donnÃ©es nouvelles.

                ### ğŸ“Š Ã‰valuation
                - Mesure de la performance sur un ensemble de test indÃ©pendant.
                - Permet de valider la qualitÃ© rÃ©elle du modÃ¨le entraÃ®nÃ©.

                ### ğŸš€ PrÃ©dictions
                - Utilisation du modÃ¨le en contexte rÃ©el pour gÃ©nÃ©rer des prÃ©dictions.
                - IntÃ©gration dans une application, un service ou un systÃ¨me automatisÃ©.
            </Column>
        </Row>
        :::

        :::tip ğŸ¯ EntraÃ®nement

        L'entraÃ®nement est le processus par lequel un modÃ¨le d'apprentissage machine apprend Ã  partir des donnÃ©es.
        Il consiste Ã  ajuster les paramÃ¨tres internes du modÃ¨le afin de minimiser une **fonction de perte** ğŸ“‰
        qui mesure l'Ã©cart entre les prÃ©dictions du modÃ¨le ğŸ¤– et les valeurs rÃ©elles ğŸ·ï¸.

        Pour obtenir un modÃ¨le **robuste et performant**, l'entraÃ®nement nÃ©cessite souvent des ressources importantes :

        - **ğŸ“Š DonnÃ©es** : Plus il y a de donnÃ©es de qualitÃ©, meilleur sera l'apprentissage.
        - **â±ï¸ Temps de calcul** : L'entraÃ®nement peut Ãªtre long, surtout pour les modÃ¨les complexes.
        - **ğŸ’» Puissance de calcul** : Utilisation de GPU/TPU âš¡ pour accÃ©lÃ©rer les calculs.
        - **ğŸ§  MÃ©moire** : Stockage des donnÃ©es et des paramÃ¨tres du modÃ¨le pendant l'entraÃ®nement.
        - **ğŸ”‹ Ã‰nergie** : Consommation Ã©nergÃ©tique importante liÃ©e au matÃ©riel informatique intensif.
        :::

        :::warning ğŸ”¥ Surapprentissage (overfitting) et jeux de donnÃ©es

        Le **surapprentissage** se produit lorsqu'un modÃ¨le apprend *trop bien* les dÃ©tails et le **bruit** des donnÃ©es d'entraÃ®nement,
        au point de perdre sa capacitÃ© Ã  **gÃ©nÃ©raliser** Ã  de nouvelles donnÃ©es.

        Ce concept peut sembler contre-intuitif ğŸ¤” : comment un modÃ¨le peut-il Ãªtre *trop bon* ?

        Imaginez un Ã©tudiant qui **mÃ©morise par cÅ“ur** chaque question dâ€™un examen passÃ© ğŸ“šğŸ§ ,
        sans comprendre rÃ©ellement les concepts. Lorsquâ€™il est confrontÃ© Ã  un nouvel examen avec des questions diffÃ©rentes â“â¡ï¸â“, il Ã©choue.

        Le surapprentissage est similaire :
        le modÃ¨le performe **exceptionnellement bien** sur lâ€™entraÃ®nement ğŸ’¯,
        mais Ã©choue sur des donnÃ©es jamais vues auparavant ğŸš«.

        Pour Ã©viter ce problÃ¨me, plusieurs stratÃ©gies existent :
        - **ğŸ›¡ï¸ RÃ©gularisation**
        - **â³ ArrÃªt prÃ©coce (*early stopping*)**
        - **ğŸ“‚ SÃ©paration des donnÃ©es** en ensembles d'entraÃ®nement, validation et test

        :::

        :::tip ğŸ¯ SÃ©paration des donnÃ©es

        Pour prÃ©venir le surapprentissage (*overfitting*), un jeu de donnÃ©es est gÃ©nÃ©ralement divisÃ© en **trois ensembles distincts**, chacun ayant un rÃ´le bien prÃ©cis.<br />
        On pourrait par exemple utiliser la rÃ©partition classique **70% - 15% - 15%** :

        ```mermaid
        flowchart TD
        A["ğŸ“‚ Jeu de donnÃ©es complet"] --> B["ğŸ“˜ 70% EntraÃ®nement"]
        A --> C["ğŸ“™ 15% Validation"]
        A --> D["ğŸ“— 15% Test"]
        ```

        ### Les trois ensembles
        - **ğŸ“˜ EntraÃ®nement (*training set*)**
          Sert Ã  **apprendre** : le modÃ¨le ajuste ses paramÃ¨tres internes.
        - **ğŸ“™ Validation (*validation set*)**
          UtilisÃ© pour **ajuster les hyperparamÃ¨tres** et surveiller le surapprentissage durant lâ€™entraÃ®nement.
        - **ğŸ“— Test (*test set*)**
          UtilisÃ© **uniquement Ã  la fin** pour mesurer la performance rÃ©elle du modÃ¨le sur des donnÃ©es jamais vues.

        ### Exemple pratique

        Pour un jeu de **1000 Ã©chantillons** ğŸ§ª :

        - **70%** â†’ 700 pour lâ€™entraÃ®nement
        - **15%** â†’ 150 pour la validation
        - **15%** â†’ 150 pour le test

        La sÃ©paration doit Ãªtre faite **alÃ©atoirement** ğŸ² pour garantir que chaque ensemble reste reprÃ©sentatif.
        :::

        :::info Exemples d'algorithmes courants
        Voici quelques algorithmes d'apprentissage machine couramment utilisÃ©s, classÃ©s par type :
        | Type | Algorithmes | Description |
        |------|-------------|-------------|
        | RÃ©gression | RÃ©gression linÃ©aire, rÃ©gression logistique | PrÃ©dire une valeur continue ou une probabilitÃ© |
        | Arbres de dÃ©cision | CART, Random Forest, Gradient Boosting | ModÃ¨les basÃ©s sur des rÃ¨gles hiÃ©rarchiques |
        | Machines Ã  vecteurs de support | SVM | Trouver l'hyperplan optimal pour la classification |
        | RÃ©seaux de neurones | Perceptron, CNN, RNN | ModÃ¨les en couches pour donnÃ©es complexes |
        | Clustering | K-means, DBSCAN | Regrouper des donnÃ©es non Ã©tiquetÃ©es en clusters |
        :::

        :::note Exemple d'implÃ©mentation avec scikit-learn
        Voici un exemple simple d'utilisation de la bibliothÃ¨que `scikit-learn` en Python pour effectuer une **classification supervisÃ©e** sur un vrai jeu de donnÃ©es classique : le jeu de donnÃ©es **Iris** (`sklearn.datasets.load_iris`).

        Ce script suit les grandes Ã©tapes du pipeline vu plus haut :
        chargement des donnÃ©es â†’ sÃ©paration entraÃ®nement/validation/test â†’ entraÃ®nement â†’ Ã©valuation â†’ prÃ©dictions.

        Vous pouvez le rouler tel quel dans un environnement Python avec `scikit-learn` installÃ©.

        ```python
        # 1. Import des bibliothÃ¨ques nÃ©cessaires
        from sklearn.datasets import load_iris
        from sklearn.model_selection import train_test_split
        from sklearn.pipeline import make_pipeline
        from sklearn.preprocessing import StandardScaler
        from sklearn.linear_model import LogisticRegression
        from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

        # 2. Charger le jeu de donnÃ©es Iris
        iris = load_iris()
        X = iris.data           # CaractÃ©ristiques (features) : mesures des fleurs
        y = iris.target         # Ã‰tiquettes (labels) : espÃ¨ce d'Iris (0, 1 ou 2)

        print("Noms des features :", iris.feature_names)
        print("Noms des classes  :", iris.target_names)
        print("Taille du jeu de donnÃ©es :", X.shape, "Ã©chantillons\n")

        # 3. SÃ©parer les donnÃ©es en train / validation / test
        #    Ici, on commence par sÃ©parer en (train+val) et test,
        #    puis on re-sÃ©pare train+val en train et val.

        # 15% des donnÃ©es pour le test final
        X_temp, X_test, y_temp, y_test = train_test_split(
            X, y, test_size=0.15, random_state=42, stratify=y
        )

        # Sur le 85% restant, on garde 70% pour l'entraÃ®nement et 15% pour la validation
        # 15% de 100% = 0.15 â†’ 15% de 85% â‰ˆ 17.6% â†’ on ajuste la proportion
        X_train, X_val, y_train, y_val = train_test_split(
            X_temp, y_temp, test_size=0.176, random_state=42, stratify=y_temp
        )

        print("Taille ensemble d'entraÃ®nement :", X_train.shape[0])
        print("Taille ensemble de validation   :", X_val.shape[0])
        print("Taille ensemble de test         :", X_test.shape[0], "\n")

        # 4. DÃ©finir un modÃ¨le + pipeline de prÃ©traitement
        #    Ici : Standardisation des features + RÃ©gression logistique
        model = make_pipeline(
            StandardScaler(),
            LogisticRegression(max_iter=1000, random_state=42)
        )

        # 5. EntraÃ®ner le modÃ¨le sur l'ensemble d'entraÃ®nement
        model.fit(X_train, y_train)

        # 6. Ã‰valuer sur l'ensemble de validation
        y_val_pred = model.predict(X_val)
        val_accuracy = accuracy_score(y_val, y_val_pred)
        print("Accuracy sur l'ensemble de validation :", round(val_accuracy, 3))

        # 7. Ã‰valuer sur l'ensemble de test (performance finale)
        y_test_pred = model.predict(X_test)
        test_accuracy = accuracy_score(y_test, y_test_pred)
        print("Accuracy sur l'ensemble de test       :", round(test_accuracy, 3), "\n")

        print("Matrice de confusion (test) :")
        print(confusion_matrix(y_test, y_test_pred), "\n")

        print("Rapport de classification (test) :")
        print(classification_report(y_test, y_test_pred, target_names=iris.target_names))
        :::

    </TabItem>

    <TabItem value="dl" label="ğŸ§ ğŸ•¸ï¸ Apprentissage profond">



    </TabItem>

    <TabItem value="ecologisation" label="ğŸŒ³ Empreinte Ã©cologique">



    </TabItem>

    <TabItem value="TP2" label="ğŸ›  TP2">
        :::tip ğŸ› 
        Profitez de cette sÃ©ance pour dÃ©buter votre [travail pratique 2](/tp/tp2).
        :::
    </TabItem>

</Tabs>
