---
hide_table_of_contents: true
---

# TP1 ğŸ¥• Calcul de racines

# ğŸ—ï¸ en construction ğŸ—

<Row>
    <Column>
        :::tip ğŸ¯ Objectifs pÃ©dagogiques
        Ã€ la fin de ce travail, vous serez capable de :

        - Utiliser des **variables**, **types de base**, **opÃ©rateurs** et **fonctions**
        - Utiliser des **structures conditionnelles** et **expressions logiques**
        - Utiliser des **structures rÃ©pÃ©titives**
        - **DÃ©composer** un algorithme en **fonctions rÃ©utilisables**
        - Ã‰valuer la **performance** dâ€™un algorithme avec des mesures de temps
        - Appliquer la logique pour rÃ©soudre un problÃ¨me **numÃ©rique complexe** sans bibliothÃ¨que
        - **Valider** le fonctionnement de vos algorithmes Ã  l'aide de **jeux d'essais**
        :::
    </Column>
    <Column>
        :::info ğŸ§  Contexte
        Un ordinateur, câ€™est trÃ¨s rapide, mais pas trÃ¨s intelligent. On va en profiter pour lui faire calculer la racine
        carrÃ©eâ€¦ de faÃ§on trÃ¨s bÃªte.

        Vous devez implÃ©menter deux mÃ©thodes de calcul Â« brutales Â» dâ€™une racine carrÃ©e :
        1. Une mÃ©thode **chiffre par chiffre**, par essais successifs
        2. Une mÃ©thode **par dichotomie** (recherche binaire)

        Puis vous devrez :
        - Comparer ces mÃ©thodes Ã  la fonction standard `math.sqrt`
        - Ã‰tendre le calcul Ã  une racine n-iÃ¨me
        :::
    </Column>
</Row>

:::note CrÃ©er le projet
Pour faire ce TP, vous devez crÃ©er un projet PyCharm dans le rÃ©pertoire GitHub Classroom crÃ©Ã© pour vous par le prof.
:::

:::danger Plagiat
Si votre travail est suspectÃ© de plagiat (code copiÃ© d'un(e) autre Ã©tudiant(e), code gÃ©nÃ©rÃ© par IA, notions non
abordÃ©es en classe, etc.), deux choses peuvent se produire :
        * Le plagiat est prouvÃ© par nos outils : note de 0, automatiquement.
        * Le plagiat est plutÃ´t Ã©vident, mais une validation est requise : vous serez convoquÃ©(e) au bureau de votre
enseignant(e). Vous devrez rÃ©pondre Ã  certaines questions pour prouver que vous comprenez et maÃ®trisez le code
qui a Ã©tÃ© utilisÃ©. Si vous ne rÃ©ussissez pas Ã  rÃ©pondre Ã  certaines questions, vous aurez la note
de 0 (si vous ne comprenez pas votre propre code, c'est que vous avez plagiÃ©, d'une maniÃ¨re ou d'une autre).
:::

:::warning <Highlight color="tip"><span style={{color: 'white'}}>2 points</span></Highlight> RÃ©pertoire Git et documentation des fonctions
- Au moins 5 commits de tailles comparables (il n'y a pas un commit avec tout dedans et les autres vides)
- Au moins 1 commit par semaine
- Les commits dÃ©crivent l'avancement du projet dans un franÃ§ais sans faute [(voir instructions)](https://info.cegepmontpetit.ca/git)
- Les fonctions doivent Ãªtre documetÃ©es dans un franÃ§ais sans faute : description de la fonction, paramÃ¨tres, limites et exceptions possibles
:::

::::note <Highlight color="tip"><span style={{color: 'white'}}>4 points</span></Highlight> ğŸ”§ Calculer la racine carrÃ©e Â« Ã  la main Â»
Voici 2 mÃ©thodes brutes pour calculer la racine carrÃ©e d'un nombre.\
Pour les dÃ©crire, supposons que nous cherchons la racine carrÃ©e de 8.

<Row>
    <Column>
        :::info â¤ MÃ©thode 1 : Chiffre par chiffre
        On construit le rÃ©sultat dÃ©cimale par dÃ©cimale, en commenÃ§ant par la plus grande.

        Pour 8, on commence donc par l'unitÃ© :
        - 0Â² = 0
        - 1Â² = 1
        - 2Â² = 4
        - 3Â² = 9

        Comme **8** est entre 4 et 9, on sait que la racine de 8 est entre 2 et 3, car 3Â² est plus grand que 8.
        Donc, la racine de 8 ressemble Ã  2 point quelque chose (ex : 2.0..., 2.1..., ..., 2.9...). 

        On passe Ã  la premiÃ¨re dÃ©cimale :
        - 2.0Â² = 4
        - 2.1Â² = 4.41
        - 2.2Â² = 4.84
        - 2.3Â² = 5.29
        - 2.4Â² = 5.76
        - 2.5Â² = 6.25
        - 2.6Â² = 6.76
        - 2.7Â² = 7.29
        - 2.8Â² = 7.84
        - 2.9Â² = 8.41

        La racine de 8 ressemble donc Ã  2.8...., car 2.9Â² est plus grand que 8.

        Et on fait ainsi de suite pour les dÃ©cimales suivantes.\
        On fait des essais successifs pour chaque dÃ©cimale jusquâ€™Ã  la prÃ©cision dÃ©sirÃ©e.
        :::
    </Column>
    <Column>
        :::info â¤ MÃ©thode 2 : Dichotomie
        On cherche dans un intervalle [bas, haut] qui se rÃ©duit de moitiÃ© Ã  chaque Ã©tape :

        DÃ©but : [0, 8] â†’ milieu = 4 â†’ 4Â² = 16 â†’ trop grand \
        â†’ nouvel intervalle [0, 4] â†’ milieu = 2 â†’ 2Â² = 4 â†’ trop petit \
        â†’ nouvel intervalle [2, 4] â†’ etc.

        On continue ainsi jusqu'Ã  la prÃ©cision dÃ©sirÃ©e.    \
        Comment savoir qu'on a atteint la prÃ©cision dÃ©sirÃ©e?  \
        Il faut regarder la diffÃ©rence entre les 2 intervalles (haut et bas).  \
        Si elle est infÃ©rieure Ã  la prÃ©cision souhaitÃ©e, on peut alors considÃ©rer qu'on a suffisamment rÃ©duit l'intervalle et qu'on a trouvÃ© la rÃ©ponse. \
         \
        La rÃ©ponse recherchÃ©e sera alors la moyenne entre les 2 intervalles.
        \
        \
        Exemple
        \
        \
        Si on souhaite 2 dÃ©cimales de prÃ©cision, 
        on devrait alors arrÃªter quand la diffÃ©rence entre les 2 intervalles est infÃ©rieure Ã  0.001
        \
        \
            DÃ©but : [0, 8] â†’ 8 - 0 = 8 ... c'est > 0.001 â†’ on continue ... \
                    nouvel intervalle [0, 4] â†’ 4 - 0 = 4 ... c'est > 0.001 â†’ on continue \
                    nouvel intervalle [2, 4] â†’ 4 - 2 = 2 ... c'est > 0.001 â†’ on continue \
                    ... \
                    nouvel intervalle [2.828125, 2.8291015625] â†’ \
                    2.8291015625 - 2.828125 = 0.0009765625... c'est < 0.001 â†’ on arrÃªte
                    
                    La rÃ©ponse est la moyenne des 2 intervalles qu'on arrondie Ã  2 dÃ©cimales.

        :::

        Pour **chacune des deux mÃ©thodes**, vous devez crÃ©er une fonction qui prendra un nombre en paramÃ¨tre et renverra
        la racine
        carrÃ©e de ce nombre en utilisant cette mÃ©thode, avec une prÃ©cision de 0.001.

        :::tip âœ… Tests attendus

        Pour chacune des 2 mÃ©thodes, affichez le rÃ©sultat des appels suivants :

        ```python
        print(nom_de_la_fonction(0))
        print(nom_de_la_fonction(0.1))
        print(nom_de_la_fonction(0.2))
        print(nom_de_la_fonction(0.9))
        print(nom_de_la_fonction(8))
        print(nom_de_la_fonction(9))
        print(nom_de_la_fonction(81))
        print(nom_de_la_fonction(123))
        print(nom_de_la_fonction(-3)) # Doit lever une exception
        ```
        :::
    </Column>
</Row>
::::
<Row>
    <Column>
        :::note <Highlight color="tip"><span style={{color: 'white'}}>2 points</span></Highlight> ğŸ“ˆ Comparaison des performances
        Vous allez comparer vos mÃ©thodes avec `math.sqrt` sur 10 000 nombres pseudo-alÃ©atoires. Pour y parvenir, vous devez :

        1. Ã€ l'aide d'une boucle, gÃ©nÃ©rez  **10 000 nombres flottants** alÃ©atoires entre 10 et 1000.
        2. ChronomÃ©trer le temps pour :
        - Calculer toutes les racines avec **votre premiÃ¨re fonction**
        - Calculer les racines avec **votre deuxiÃ¨me fonction**
        - Calculer les racines avec **`math.sqrt()`**
        3. Afficher :
        - Le **temps total (en nanosecondes)** pour chaque mÃ©thode
        - Le **temps moyen** par appel de fonction pour chaque mÃ©thode
        :::
    </Column>
    <Column>
        :::tip <Highlight color="tip"><span style={{color: 'white'}}>2 points</span></Highlight> ğŸŒ± GÃ©nÃ©raliser Ã  une racine n-iÃ¨me
        Pour chacune de vos 2 fonctions, faites-en une copie et gÃ©nÃ©ralisez-la pour qu'elle calcule la
        racine n-iÃ¨me d'un nombre. \
        \
        Vous devez rajouter un paramÃ¨tre `base` (ex. : 2 pour racine carrÃ©e, 3 pour racine cubique, etc.).
        Il suffit ensuite de faire un changement minime aux 2 algorithmes pour calculer n'importe quelle racine n-iÃ¨me.

        Appelez chacune de ces 2 nouvelles fonctions et affichez les rÃ©sultats pour la racine carrÃ©e, cubique et
        quatriÃ¨me de 8, 9, 81 et 123.
        :::
    </Column>
</Row>

:::danger Fonctionnement global <Highlight color="danger"><span style={{color: 'white'}}>2 points nÃ©gatifs</span></Highlight>
Le projet fonctionne sans plantage et correctement, et le code est clair et facile Ã  lire.
Ce pointage fonctionne en nÃ©gatif.
Si le projet fonctionne correctement en tout temps, vous conservez votre note.
Dans le cas contraire, vous perdez des points avec un maximum de 2.

- Plantage <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Code illisible <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Information affichÃ©e incohÃ©rente <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Autre cas...
:::


