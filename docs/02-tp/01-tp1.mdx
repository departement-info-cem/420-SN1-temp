---
hide_table_of_contents: true
---

# TP1 ü•ï Calcul de racines

<Row>
    <Column>
        :::info üß† Contexte
        Un ordinateur, c‚Äôest tr√®s rapide, mais pas tr√®s intelligent. On va en profiter pour lui faire calculer la racine
        carr√©e‚Ä¶ de fa√ßon tr√®s b√™te.

        Vous devez impl√©menter deux m√©thodes de calcul ¬´ brutales ¬ª d‚Äôune racine carr√©e :
        1. Une m√©thode **chiffre par chiffre**, par essais successifs
        2. Une m√©thode **par dichotomie** (recherche binaire)

        Puis vous devrez :
        - Comparer ces m√©thodes √† la fonction standard `math.sqrt()` en termes de performance
        - √âtendre le calcul √† une racine n-i√®me
        :::
    </Column>
    <Column>
        :::tip üéØ Objectifs p√©dagogiques
        √Ä la fin de ce travail, vous serez capable de :

        - Utiliser des variables, types de base, op√©rateurs et fonctions
        - Utiliser des structures conditionnelles et expressions logiques
        - Utiliser des structures r√©p√©titives
        - D√©composer un algorithme en fonctions r√©utilisables
        - √âvaluer la performance d‚Äôun algorithme avec des mesures de temps
        - Appliquer la logique pour r√©soudre un probl√®me num√©rique complexe sans biblioth√®que
        - Valider le fonctionnement de vos algorithmes √† l'aide de jeux d'essais
        :::
    </Column>
</Row>

:::note Cr√©er le projet
Pour faire ce TP, vous devez cr√©er un nouveau projet PyCharm et utiliser un r√©pertoire GitHub d√®s le d√©but.

- Si votre enseignant utilise GitHub Classroom, utilisez le r√©pertoire cr√©√© par votre enseignant.
- Si votre enseignant n'utilise pas GitHub Classroom, cr√©ez votre propre r√©pertoire et partagez-lui l'acc√®s en lecture.
:::

:::danger Plagiat
# ‚ùóü§ñ üëÄ üö´
Si votre travail est suspect√© de plagiat (code copi√© d'un.e autre √©tudiant.e, code g√©n√©r√© par IA, notions non
abord√©es en classe, etc.), deux choses peuvent se produire :
        * Le plagiat est prouv√© par nos outils : note de 0, automatiquement.
        * Le plagiat est plut√¥t √©vident, mais une validation est requise : vous serez convoqu√©(e) au bureau de votre
enseignant(e). Vous devrez r√©pondre √† certaines questions pour prouver que vous comprenez et ma√Ætrisez le code
qui a √©t√© utilis√©. Si vous ne r√©ussissez pas √† r√©pondre √† certaines questions, vous aurez la note
de 0 (si vous ne comprenez pas votre propre code, c'est que vous avez plagi√©, d'une mani√®re ou d'une autre).
:::

:::warning <Highlight color="tip"><span style={{color: 'white'}}>1 point</span></Highlight> R√©pertoire Git üêà‚Äç‚¨õ et documentation des fonctions
- Au moins 5 commits de tailles comparables (il n'y a pas un commit avec tout dedans et les autres vides)
- Les commits d√©crivent l'avancement du projet dans un fran√ßais sans faute [(voir instructions)](https://info.cegepmontpetit.ca/git)
- Chaque fonction doit √™tre document√©e √† l'aide d'un  [docstring](/cours/rencontre3?onglet=comments)  dans un fran√ßais sans faute : description de la fonction, param√®tres, valeur retourn√©e, exceptions possibles, etc.
- Votre projet doit contenir exactement 3 scripts Python et rien d'autre :
```
tp1/
‚îú‚îÄ‚îÄ racine.py       # doit contenir vos 2 fonctions pour les 2 m√©thodes diff√©rentes du calcul de la racine carr√©e
‚îú‚îÄ‚îÄ validation.py   # doit contenir vos tests validant le bon fonctionnement des fonctions du module "racine.py"
‚îî‚îÄ‚îÄ performance.py  # doit contenir vos tests de performance des fonctions du module "racine.py"
```
:::

::::note <Highlight color="tip"><span style={{color: 'white'}}>6 points</span></Highlight> üîß Calculer la racine carr√©e ¬´ √† la main ¬ª
Dans le script `racine.py`, vous devez cr√©er 2 fonctions, soit une pour chacune des deux m√©thodes du calcul de la racine carr√©e d'un nombre.\
Pour d√©crire ces m√©thodes de calcul, supposons que nous cherchons la racine carr√©e de $8$.

<Row>
    <Column>
        :::info ‚û§ M√©thode 1 : Chiffre par chiffre
        On construit le r√©sultat d√©cimale par d√©cimale, en commen√ßant par la plus grande.

        Pour $8$, on commence donc par l'unit√© :
        - $0^2 = 0$
        - $1^2 = 1$
        - $2^2 = 4$
        - $3^2 = 9$

        Comme $8$ est entre $4$ et $9$, on sait que la racine de $8$ est entre $2$ et $3$, car $3^2$ est plus grand que $8$.
        Donc, la racine de $8$ ressemble √† $2$ point quelque chose (ex : $2.0..., 2.1..., ..., 2.9...$).

        On passe √† la premi√®re d√©cimale :
        - $2.0^2 = 4$
        - $2.1^2 = 4.41$
        - $2.2^2 = 4.84$
        - $2.3^2 = 5.29$
        - $2.4^2 = 5.76$
        - $2.5^2 = 6.25$
        - $2.6^2 = 6.76$
        - $2.7^2 = 7.29$
        - $2.8^2 = 7.84$
        - $2.9^2 = 8.41$

        La racine de $8$ ressemble donc √† $2.8....$, car $2.9^2$ est plus grand que $8$.

        Et on fait ainsi de suite pour les d√©cimales suivantes. On fait des essais successifs pour chaque d√©cimale jusqu‚Äô√† la pr√©cision d√©sir√©e.
        :::
    </Column>
    <Column>
        :::info ‚û§ M√©thode 2 : Dichotomie
        On cherche la racine dans un intervalle $[\text{bas}, \text{haut}]$ qui se r√©duit de moiti√© √† chaque √©tape.

        On commence par d√©terminer l'intervalle initial :

        $$
        \text{Si}
            \begin{cases}
                n \ge 1 : & \text{intervalle initial} = [0, n],\\
                0 < n < 1 : & \text{intervalle initial} = [n, 1],\\
                n = 0 : & \text{racine} = 0,\\
                n < 0 : & \text{non d√©fini dans } \mathbb{R}\ : \text{on l√®ve une exception}.
            \end{cases}
        $$

        Par la suite, on va r√©duire l'intervalle de moiti√© de la mani√®re suivante :
        - On calcule le $\text{milieu} = \frac{\text{bas} + \text{haut}}{2}$, puis :
        $$
        \text{Si}
            \begin{cases}
                \text{milieu}^2 < n: & \text{on d√©place bas = milieu},\\
                \text{milieu}^2 \ge n: & \text{on d√©place haut = milieu}.
            \end{cases}
        $$

        On r√©p√®te l'op√©ration de r√©duction de l'intervalle jusqu'√† ce que la largeur de l‚Äôintervalle ($\text{haut} - \text{bas}$) soit inf√©rieure √† la pr√©cision souhait√©e.
        √Ä ce moment, la racine est approxim√©e par $\frac{\text{bas} + \text{haut}}{2}$.

        **Exemple (racine de $8$, avec $3$ d√©cimales de pr√©cision)**<br />
        On arr√™te quand la largeur de l‚Äôintervalle $< 0.001$ :
        - $[0, 8]$ ‚Üí $\text{largeur} = 8 \ge 0.001$ ‚Üí on continue
        - $[0, 4]$ ‚Üí $\text{largeur} = 4 \ge 0.001$ ‚Üí on continue
        - $[2, 4]$ ‚Üí $\text{largeur} = 2 \ge 0.001$ ‚Üí on continue
        - ...
        - $[2.828125, 2.8291015625]$ ‚Üí $\text{largeur} = 0.0009765625 < 0.001$ ‚Üí on arr√™te

        R√©sultat $\approx \frac{2.828125 + 2.8291015625}{2} = 2.82861328125 \approx 2.829$ (arrondi √† $3$ d√©cimales).
        :::
    </Column>
</Row>

Les 2 fonctions doivent prendre un seul param√®tre, un nombre, et retourner sa racine carr√©e.

La **pr√©cision** doit √™tre **entre 4 et 12 d√©cimales** √† votre discr√©tion. \
Sup√©rieur √† 12 d√©cimales, le calcul peut prendre trop de temps et le programme peut arr√™ter de fonctionner. \
Mettez la pr√©cision de votre choix dans une variable globale constante (ex : `PRECISION = 8`), avant vos d√©finitions de fonctions.

:::danger GARDER LE MODULE `RACINE` PROPRE
Votre module `racine` doit contenir uniquement ces 2 fonctions et aucune instruction dans ce module ne doit √™tre plac√©e √† l'ext√©rieur de ces 2 fonctions (sauf la constante).
:::

:::tip ‚úÖ Tests attendus

Dans le script `validation.py`, importez le module `racine` puis tester vos 2 fonctions √† l'aide d'appels de fonction similaires √† ceux-ci :

```python
try:
    print("*** V√âRIFICATION DU BON FONCTIONNEMENT ***")
    print("attendu : 0.0 ")
    print(" obtenu :", racine.nom_de_la_fonction(0))
    print("attendu : 0.31622776601683794")
    print(" obtenu :", racine.nom_de_la_fonction(0.1))
    print("attendu : 0.4472135954999579")
    print(" obtenu :", racine.nom_de_la_fonction(0.2))
    print("attendu : 0.9486832980505138")
    print(" obtenu :", racine.nom_de_la_fonction(0.9))
    print("attendu : 2.8284271247461903")
    print(" obtenu :", racine.nom_de_la_fonction(8))
    print("attendu : 3.0")
    print(" obtenu :", racine.nom_de_la_fonction(9))
    print("attendu : 9.0")
    print(" obtenu :", racine.nom_de_la_fonction(81))
    print("attendu : 11.090536506409418")
    print(" obtenu :", racine.nom_de_la_fonction(123))
    print("attendu : 31.606961258558215")
    print(" obtenu :", racine.nom_de_la_fonction(999))
    print(nom_de_la_fonction(-3))   # Doit lever une exception
except e as Exception:
    print(f"erreur {e}")
```

**Remarque** : les r√©sultats attendus affich√©s sont les r√©sultats de `math.sqrt()`. \
Assurez-vous pour tous les tests que les d√©cimales obtenues sont les bonnes et les arrondis sont coh√©rents selon votre niveau de pr√©cision. \
Voici 2 exemples d'erreurs :
```python
    attendu : 2.8284271247461903
     obtenu : 2.82842               # Mauvaise r√©ponse, car le dernier 2 aurait d√ª √™tre un 3

    attendu : 2.8284271247461903
     obtenu : 2.8284265122345312    # Mauvaise r√©ponse, car certaines d√©cimales sont fausses
```

:::

::::
:::note <Highlight color="tip"><span style={{color: 'white'}}>2 points</span></Highlight> üìà Comparaison des performances
Dans le script `performance.py`, vous allez comparer vos 2 fonctions du module `racine` avec la fonction `math.sqrt()` pour comparer leurs performances.

**Pour chacune des 3 m√©thodes** (fonction 1, fonction 2, `math.sqrt()`) vous devez :
- √Ä l'aide d'une boucle, appeler la fonction 100 000 fois avec un nombre flottant al√©atoire
    - Utilisez un nombre flottant al√©atoire diff√©rent √† chaque appel
    - Les nombres flottants g√©n√©r√©s doivent √™tre compris entre 10 et 10 000
- Calculer le temps total n√©cessaire pour r√©aliser les 100 000 appels (en ms)
- Afficher :
    - Le **temps de calcul total** pour les 100 000 appels (en **millisecondes**)
    - Le **temps moyen** par appel de la fonction

Exemple d'affichage attendu (les valeurs sont fictives) :
```python
R√©sultats des performances :
M√©thode 1 (chiffre par chiffre) : Temps total = 150 ms, Temps moyen = 0.0015 ms
M√©thode 2 (dichotomie)          : Temps total = 50 ms, Temps moyen = 0.0005 ms
M√©thode 3 (math.sqrt)           : Temps total = 10 ms, Temps moyen = 0.0001 ms
```
:::

:::tip <Highlight color="tip"><span style={{color: 'white'}}>1 point</span></Highlight> üå± G√©n√©raliser √† une racine n-i√®me
Vous devez **transformer** vos 2 fonctions du module `racine` afin qu'elles puissent calculer la racine n-i√®me d'un nombre.

Pour cela :
- Vous devez ajouter un param√®tre `base` √† vos fonctions (ex. : 2 pour racine carr√©e, 3 pour racine cubique, etc.). Ce param√®tre doit √™tre optionnel et avoir par d√©faut la valeur 2.<br />
- La racine carr√©e d'un nombre n√©gatif doit √™tre possible uniquement si la base est impaire (ex. : la racine cubique de -27 est -3), sinon une exception doit encore √™tre lev√©e.
- La valeur du param√®tre `base` ne doit pas √™tre inf√©rieure √† 2 (validation de la valeur pass√©e en param√®tre n√©cessaire).

Appelez chacune de ces 2 nouvelles fonctions et affichez les r√©sultats pour la racine carr√©e, cubique et
quatri√®me de 8, 9, 81 et 123.

```python
try:
    print("*** RACINE DEUX ***")
    print("attendu : 2.8284271247461903")
    print(" obtenu :", racine.nom_de_la_fonction(8,2))
    print("attendu : 3.0")
    print(" obtenu :", racine.nom_de_la_fonction(9,2))
    print("attendu : 9.0")
    print(" obtenu :", racine.nom_de_la_fonction(81,2))
    print("attendu : 11.090536506409418")
    print(" obtenu :", racine.nom_de_la_fonction(123,2))

    print("*** RACINE CUBIQUE ***")
    print("attendu : 2.0")
    print(" obtenu :", racine.nom_de_la_fonction(8,3))
    print("attendu : 2.080083823051904")
    print(" obtenu :", racine.nom_de_la_fonction(9,3))
    print("attendu : 4.3267487109222245")
    print(" obtenu :", racine.nom_de_la_fonction(81,3))
    print("attendu : 4.97318983326859")
    print(" obtenu :", racine.nom_de_la_fonction(123,3))

    print("*** RACINE QUATRIEME ***")
    print("attendu : 1.681792830507429")
    print(" obtenu :", racine.nom_de_la_fonction(8,4))
    print("attendu : 1.7320508075688772")
    print(" obtenu :", racine.nom_de_la_fonction(9,4))
    print("attendu : 3.0")
    print(" obtenu :", racine.nom_de_la_fonction(81,4))
    print("attendu : 3.3302457126178266")
    print(" obtenu :", racine.nom_de_la_fonction(123,4))
except e as Exception:
    print(f"erreur {e}")

```
:::

:::danger Fonctionnement global <Highlight color="danger"><span style={{color: 'white'}}>2 points n√©gatifs</span></Highlight>
Le projet fonctionne sans plantage et correctement, et le code est clair et facile √† lire.
Ce pointage fonctionne en n√©gatif.
Si le projet fonctionne correctement en tout temps, vous conservez votre note.
Dans le cas contraire, vous perdez des points avec un maximum de 2.

- Plantage <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Code illisible <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Information affich√©e incoh√©rente <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Autre cas...
:::


