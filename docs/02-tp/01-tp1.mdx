---
hide_table_of_contents: true
---

# TP1 ğŸ¥• Calcul de racines

<Row>
    <Column>
        :::info ğŸ§  Contexte
        Un ordinateur, câ€™est trÃ¨s rapide, mais pas trÃ¨s intelligent. On va en profiter pour lui faire calculer la racine
        carrÃ©eâ€¦ de faÃ§on trÃ¨s bÃªte.

        Vous devez implÃ©menter deux mÃ©thodes de calcul Â« brutales Â» dâ€™une racine carrÃ©e :
        1. Une mÃ©thode **chiffre par chiffre**, par essais successifs
        2. Une mÃ©thode **par dichotomie** (recherche binaire)

        Puis vous devrez :
        - Comparer ces mÃ©thodes Ã  la fonction standard `math.sqrt`
        - Ã‰tendre le calcul Ã  une racine n-iÃ¨me
        :::
    </Column>
    <Column>
        :::tip ğŸ¯ Objectifs pÃ©dagogiques
        Ã€ la fin de ce travail, vous serez capable de :

        - Utiliser des variables, types de base, opÃ©rateurs et fonctions
        - Utiliser des structures conditionnelles et expressions logiques
        - Utiliser des structures rÃ©pÃ©titives
        - DÃ©composer un algorithme en fonctions rÃ©utilisables
        - Ã‰valuer la performance dâ€™un algorithme avec des mesures de temps
        - Appliquer la logique pour rÃ©soudre un problÃ¨me numÃ©rique complexe sans bibliothÃ¨que
        - Valider le fonctionnement de vos algorithmes Ã  l'aide de jeux d'essais
        :::
    </Column>
</Row>

:::note CrÃ©er le projet
Pour faire ce TP, vous devez crÃ©er un nouveau projet PyCharm et utiliser un rÃ©pertoire GitHub dÃ¨s le dÃ©but.

- Si votre enseignant utilise GitHub Classroom, utilisez le rÃ©pertoire crÃ©Ã© par votre enseignant.
- Si votre enseignant n'utilise pas GitHub Classroom, crÃ©ez votre propre rÃ©pertoire et partagez-lui l'accÃ¨s en lecture.
:::

:::danger Plagiat
# â—ğŸ¤– ğŸ‘€ ğŸš«
Si votre travail est suspectÃ© de plagiat (code copiÃ© d'un(e) autre Ã©tudiant(e), code gÃ©nÃ©rÃ© par IA, notions non
abordÃ©es en classe, etc.), deux choses peuvent se produire :
        * Le plagiat est prouvÃ© par nos outils : note de 0, automatiquement.
        * Le plagiat est plutÃ´t Ã©vident, mais une validation est requise : vous serez convoquÃ©(e) au bureau de votre
enseignant(e). Vous devrez rÃ©pondre Ã  certaines questions pour prouver que vous comprenez et maÃ®trisez le code
qui a Ã©tÃ© utilisÃ©. Si vous ne rÃ©ussissez pas Ã  rÃ©pondre Ã  certaines questions, vous aurez la note
de 0 (si vous ne comprenez pas votre propre code, c'est que vous avez plagiÃ©, d'une maniÃ¨re ou d'une autre).
:::

:::warning <Highlight color="tip"><span style={{color: 'white'}}>1 point</span></Highlight> RÃ©pertoire Git et documentation des fonctions
- Au moins 5 commits de tailles comparables (il n'y a pas un commit avec tout dedans et les autres vides)
- Les commits dÃ©crivent l'avancement du projet dans un franÃ§ais sans faute [(voir instructions)](https://info.cegepmontpetit.ca/git)
- Chaque fonction doit Ãªtre documentÃ©e Ã  l'aide d'un  [docstring](/cours/rencontre3?onglet=comments)  dans un franÃ§ais sans faute : description de la fonction, paramÃ¨tres, limites et exceptions possibles.
- Votre projet doit contenir exactement 3 scripts Python et rien d'autre :
```
tp1/
â”œâ”€â”€ racine.py       #sert Ã  contenir vos 2 fonctions pour les 2 mÃ©thodes diffÃ©rentes de calcul la racine carrÃ©e
â”œâ”€â”€ validation.py   #sert Ã  contenir vos tests validant le bon fonctionnement des fonctions du module "racine.py"
â””â”€â”€ performance.py  #sert Ã  contenir vos tests de performance des fonctions du module "racine.py"
```
:::

::::note <Highlight color="tip"><span style={{color: 'white'}}>6 points</span></Highlight> ğŸ”§ Calculer la racine carrÃ©e Â« Ã  la main Â»
Voici 2 mÃ©thodes brutes pour calculer la racine carrÃ©e d'un nombre.\
Pour les dÃ©crire, supposons que nous cherchons la racine carrÃ©e de 8.

<Row>
    <Column>
        :::info â¤ MÃ©thode 1 : Chiffre par chiffre
        On construit le rÃ©sultat dÃ©cimale par dÃ©cimale, en commenÃ§ant par la plus grande.

        Pour 8, on commence donc par l'unitÃ© :
        - 0Â² = 0
        - 1Â² = 1
        - 2Â² = 4
        - 3Â² = 9

        Comme **8** est entre 4 et 9, on sait que la racine de 8 est entre 2 et 3, car 3Â² est plus grand que 8.
        Donc, la racine de 8 ressemble Ã  2 point quelque chose (ex : 2.0..., 2.1..., ..., 2.9...). 

        On passe Ã  la premiÃ¨re dÃ©cimale :
        - 2.0Â² = 4
        - 2.1Â² = 4.41
        - 2.2Â² = 4.84
        - 2.3Â² = 5.29
        - 2.4Â² = 5.76
        - 2.5Â² = 6.25
        - 2.6Â² = 6.76
        - 2.7Â² = 7.29
        - 2.8Â² = 7.84
        - 2.9Â² = 8.41

        La racine de 8 ressemble donc Ã  2.8...., car 2.9Â² est plus grand que 8.

        Et on fait ainsi de suite pour les dÃ©cimales suivantes. On fait des essais successifs pour chaque dÃ©cimale jusquâ€™Ã  la prÃ©cision dÃ©sirÃ©e.
        :::
    </Column>
    <Column>
        :::info â¤ MÃ©thode 2 : Dichotomie
        On cherche la racine dans un intervalle [bas, haut] qui se rÃ©duit de moitiÃ© Ã  chaque Ã©tape.

        On commence par dÃ©terminer l'intervalle initial :

        - Si n â‰¥ 1 : intervalle initial = [0, n]
        - Si 0 < n < 1 : intervalle initial = [n, 1]
        - Si n = 0 : la racine est 0
        - Si n < 0 : la racine n'existe pas dans les rÃ©els (on lÃ¨ve une exception)

        Par la suite, on va rÃ©duire l'intervalle de moitiÃ© de la maniÃ¨re suivante :
        - On calcule le milieu = (bas + haut) / 2
        - Si milieuÂ² est plus petit que n, on dÃ©place bas = milieu
        - Si milieuÂ² est plus grand ou Ã©gal Ã  n, on dÃ©place haut = milieu

        On rÃ©pÃ¨te l'opÃ©ration de rÃ©duction de l'intervalle jusqu'Ã  ce que la largeur de lâ€™intervalle (haut - bas) soit infÃ©rieure Ã  la prÃ©cision souhaitÃ©e.
        Dans ce cas, la racine est approximÃ©e par (bas + haut) / 2.

        **Exemple (racine de 8, 3 dÃ©cimales de prÃ©cision)**
        On arrÃªte quand la largeur de lâ€™intervalle < 0.001 :
        - [0, 8] â†’ largeur = 8 > 0.001 â†’ on continue
        - [0, 4] â†’ largeur = 4 > 0.001 â†’ on continue
        - [2, 4] â†’ largeur = 2 > 0.001 â†’ on continue
        â€¦
        - [2.828125, 2.8291015625] â†’ largeur = 0.0009765625 < 0.001 â†’ on arrÃªte

        RÃ©sultat â‰ˆ (2.828125 + 2.8291015625) / 2 = 2.82861328125 â‰ˆ **2.829** (arrondi Ã  3 dÃ©cimales).
        :::
    </Column>
</Row>

Pour **chacune des deux mÃ©thodes**, vous devez crÃ©er une fonction dans le module `racine.py` prenant un nombre en paramÃ¨tre et retournant sa racine carrÃ©e en utilisant cette mÃ©thode. **Les 2 fonctions doivent recevoir** Ã  ce stade **un seul paramÃ¨tre** : **le nombre**.

La **prÃ©cision** doit Ãªtre **entre 4 et 14 dÃ©cimales** Ã  votre discrÃ©tion. \
SupÃ©rieur Ã  14 dÃ©cimales, le calcul prend trop de temps et le programme peut arrÃªter de fonctionner. \
Mettez la prÃ©cision de votre choix dans une variable Ã  l'intÃ©rieur de vos fonctions <i>(comme une constante, ex : PRECISION = 8)</i>.

:::tip âœ… Tests attendus

Dans le script `validation.py`, importez le module `racine` puis tester vos 2 fonctions Ã  l'aide d'appels de fonction similaire Ã  ceux ci-dessous :

```python
try:
    print("*** VÃ‰RIFICATION DU BON FONCTIONNEMENT ***")
    print("attendu : 0.0 ")
    print(" obtenu :", racine.nom_de_la_fonction(0))
    print("attendu : 0.31622776601683794")
    print(" obtenu :", racine.nom_de_la_fonction(0.1))
    print("attendu : 0.4472135954999579")
    print(" obtenu :", racine.nom_de_la_fonction(0.2))
    print("attendu : 0.9486832980505138")
    print(" obtenu :", racine.nom_de_la_fonction(0.9))
    print("attendu : 2.8284271247461903")
    print(" obtenu :", racine.nom_de_la_fonction(8))
    print("attendu : 3.0")
    print(" obtenu :", racine.nom_de_la_fonction(9))
    print("attendu : 9.0")
    print(" obtenu :", racine.nom_de_la_fonction(81))
    print("attendu : 11.090536506409418")
    print(" obtenu :", racine.nom_de_la_fonction(123))
    print("attendu : 31.606961258558215")
    print(" obtenu :", racine.nom_de_la_fonction(999))
    print(nom_de_la_fonction(-3))   # Doit lever une exception
except e as Exception:
    print(f"erreur {e}")
```

**Remarque** : les rÃ©sultats attendus affichÃ©s sont les rÃ©sultats de math.sqrt() \
Assurez-vous pour tous les tests que les dÃ©cimales obtenues sont les bonnes et les arrondis sont cohÃ©rents selon votre niveau de prÃ©cision. \
Voici 2 exemples d'erreurs :
```python
    attendu : 2.8284271247461903
     obtenu : 2.82842               #Mauvaise rÃ©ponse, car le dernier 2 aurait dÃ» Ãªtre un 3

    attendu : 2.8284271247461903
     obtenu : 2.8284265122345312    #Mauvaise rÃ©ponse, car certaines dÃ©cimales sont fausses
```

:::

::::
:::note <Highlight color="tip"><span style={{color: 'white'}}>2 points</span></Highlight> ğŸ“ˆ Comparaison des performances
Dans le script `performance.py`, vous allez comparer vos 2 fonctions du module `racine` avec la fonction `math.sqrt` pour comparer leurs performances.

**Pour chacune des 3 mÃ©thodes** (fonction 1, fonction 2, `math.sqrt`) vous devez :
- Ã€ l'aide d'une boucle, appeler la fonction 100 000 fois avec un nombre flottant alÃ©atoire
    - Utilisez un nombre flottant alÃ©atoire diffÃ©rent Ã  chaque appel
    - Les nombres flottants gÃ©nÃ©rÃ©s doivent Ãªtre compris entre 10 et 10 000
- Calculer le temps total nÃ©cessaire pour rÃ©aliser les 100 000 appels (en ms)
- Afficher :
    - Le **temps de calcul total** (en millisecondes)
    - Le **temps moyen** par appel de la fonction

Exemple d'affichage attendu (les valeurs sont fictives) :
```python
RÃ©sultats des performances :
MÃ©thode 1 (chiffre par chiffre) : Temps total = 150 ms, Temps moyen = 0.0015 ms
MÃ©thode 2 (dichotomie)          : Temps total = 50 ms, Temps moyen = 0.0005 ms
MÃ©thode 3 (math.sqrt)           : Temps total = 10 ms, Temps moyen = 0.0001 ms
```
:::

:::tip <Highlight color="tip"><span style={{color: 'white'}}>1 point</span></Highlight> ğŸŒ± GÃ©nÃ©raliser Ã  une racine n-iÃ¨me
Pour chacune de vos 2 fonctions, faites-en une copie, nommez-la diffÃ©remment, et gÃ©nÃ©ralisez-la pour qu'elle calcule la
racine n-iÃ¨me d'un nombre. \
\
Pour cela, vous devez ajouter un paramÃ¨tre `base` Ã  vos nouvelles fonctions (ex. : 2 pour racine carrÃ©e, 3 pour racine cubique, etc.).<br />
Il suffit ensuite de faire un changement minime aux 2 algorithmes pour calculer n'importe quelle racine n-iÃ¨me.

Appelez chacune de ces 2 nouvelles fonctions et affichez les rÃ©sultats pour la racine carrÃ©e, cubique et
quatriÃ¨me de 8, 9, 81 et 123.
:::

:::danger Fonctionnement global <Highlight color="danger"><span style={{color: 'white'}}>2 points nÃ©gatifs</span></Highlight>
Le projet fonctionne sans plantage et correctement, et le code est clair et facile Ã  lire.
Ce pointage fonctionne en nÃ©gatif.
Si le projet fonctionne correctement en tout temps, vous conservez votre note.
Dans le cas contraire, vous perdez des points avec un maximum de 2.

- Plantage <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Code illisible <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Information affichÃ©e incohÃ©rente <Highlight color="danger"><span style={{color: 'white'}}>-1 point</span></Highlight>
- Autre cas...
:::


